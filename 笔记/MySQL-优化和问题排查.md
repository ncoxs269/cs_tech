2025-11-23 16:22
Status: #idea
Tags:

# 1 MySQL有哪些优化手段
MySQL 优化需遵循「**先低成本优化（SQL / 索引 / 结构），后高成本优化（配置 / 架构）** 」的原则，核心目标是减少 IO 开销、降低锁竞争、提升并发处理能力。

## 1.1 SQL 与索引优化（最基础、性价比最高）
### 1.1.1 索引设计优化
- 针对高频查询条件创建索引，并且遵循「最左前缀原则」，将过滤性最强的字段放最左。
- 用覆盖索引（索引包含查询所需所有字段）避免回表
- 优化索引结构：减少索引大小（字符串前缀索引），去掉无用索引，使用有序字段作为索引

### 1.1.2 避免索引失效
- 不使用函数 / 表达式操作索引字段
- 避免使用 `!=`、`NOT IN`、`IS NOT NULL`
- 字符串查询加引号，避免隐式转换索引失效
- 避免 `OR` 连接非索引字段，改用  `UNION` 或 `UNION ALL`

### 1.1.3 SQL 语句优化
- 避免 `SELECT *`，只查询需要的字段
- 用 `JOIN` 替代子查询（子查询会创建临时表，效率低），且遵循「小表驱动大表」。
	- MySQL 表关联的算法是 Nest Loop Join，是通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果（**想象一下双层for循环**）。如果还有第三个参与Join，则再通过前两个表的Join结果集作为循环基础数据，再一次通过循环查询条件到第三个表中查询数据，如此往复。
	- **因此小表驱动大表，可以减少查询中的连接次数，提高查询效率**。
	- 在进行表连接（JOIN）操作时，MySQL会根据连接类型和数据量大小来决定哪个表作为驱动表。例如，使用_LEFT JOIN_时，左表是驱动表，右表是被驱动表；使用_RIGHT JOIN_时，右表是驱动表，左表是被驱动表。而在_INNER JOIN_中，MySQL会自动选择数据量较小的表作为驱动表。
	- 在小表驱动大表的策略中，为被驱动表建立索引可以显著提高执行速度。驱动表的索引通常不会被使用，而被驱动表的索引则会被有效利用。
- 分页优化：大数据量分页（如 `LIMIT 100000, 20`）改用「主键过滤」（`WHERE id > 100000 LIMIT 20`），需主键有序。
- 聚合查询优化：
	- `COUNT(*)` 优于 `COUNT(字段)`（InnoDB 优化了 `COUNT(*)`，无需全表扫描）
	- 避免 `SELECT DISTINCT`（改用索引去重）。
- 批量操作：例如不要一条一条插入数据，而是批量插入。
	- 但是注意不要一次性操作过多行，会触发大量行锁或表锁，阻塞其他请求。

## 1.2 事务和锁优化
### 1.2.1 事务优化（核心：缩短事务时长 + 减少资源占用）
- 控制事务粒度：拆分大事务为小事务
- 避免事务内包含非数据库操作
- 合理选择事务隔离级别
	- 读已提交：大多数 OLTP 场景首选
	- 可重复读：适合需要数据一致性的场景（如金融对账）
	- 串行化：仅用于强一致性要求（如银行转账核心步骤）
- 优化事务提交方式
	- 优化逻辑：默认 `autocommit=1`（自动提交），避免手动关闭自动提交后忘记 `COMMIT`（导致长事务）。
	- 避坑点：禁止在循环中开启事务（如批量插入时，不应每次插入都开启事务，可批量提交，但需平衡一致性和性能）。
- 减少事务内的锁竞争：抢锁操作尽量放在事务快结束时做，减少锁占用时间。

### 1.2.2 锁优化（核心：减少锁冲突 + 避免死锁 + 合理选锁）
- 确保行锁生效：所有 `UPDATE/DELETE` 语句的 `WHERE` 条件必须命中索引（优先主键 / 联合索引）
- 减少锁持有时间：把最可能造成锁冲突、最可能影响并发度的锁尽量往后放
- 避免间隙锁导致的死锁
	- 用等值查询替代范围查询
	- 若必须用范围查询，可降低隔离级别到「读已提交」
- 避免死锁的关键技巧
	- 统一资源申请顺序：所有事务按相同顺序访问资源。如更新多行时，按 ID 升序更新
	- 避免长时间持有锁，缩短事务时长
	- 用乐观锁替代悲观锁
- 批量操作避免全表锁：不要一次性操作过多行，分批处理

## 1.3 数据库结构优化
### 1.3.1 表结构设计优化
- 字段类型「最小化 + 精准化」：如存储手机号用 `CHAR(11)` 而非 `VARCHAR`，存储年龄用 `TINYINT UNSIGNED`（0-255）而非 `INT`。
- 避免大字段（`TEXT`、`BLOB`）：若需存储富文本，可拆分到独立表（如 `article` 表存基本信息，`article_content` 表存 `TEXT` 内容），或用对象存储（OSS）。
- 合理选择范式与反范式：OLTP 系统（On-line Transaction Processing，联机事务处理）用第三范式（减少冗余）；OLAP 系统（On-line Analytical Processing，联机分析处理）适当反范式（增加冗余字段，减少 JOIN）。
- 用 `ENUM` 存储固定选项（如订单状态 `status ENUM('pending','paid','shipped')`），比 `VARCHAR` 更省空间、查询更快。

### 1.3.2 分库分表（解决单表 / 单库瓶颈）
参见[[MySQL-分库分表]]

### 1.3.3 分区表（MySQL 内置，轻量化分表）
优化手段：
- 按范围分区（最常用）：如日志表 `log` 按 `create_time` 分区（`PARTITION BY RANGE (TO_DAYS(create_time)) (...)`）。
- 按列表分区：如按地区分区（`PARTITION BY LIST (area_id) (...)`）。
- 注意：分区表共享索引，仅解决「单表文件过大」问题，无法解决并发压力（并发高需分库分表）。

## 1.4 硬件与架构优化（解决大规模并发瓶颈）
### 1.4.1 硬件优化
- 内存：优先扩容内存（InnoDB 缓存依赖内存），内存越大，缓存命中率越高，磁盘 IO 越少。
- 磁盘：用 SSD 替代 HDD（随机 IO 性能提升 10-100 倍），高写入场景用 NVMe SSD。
- CPU：选择多核 CPU（MySQL 支持多线程，并发查询依赖多核），如 16 核 / 32 核。
- 网络：用万兆网卡，避免高并发时网络带宽瓶颈（如主从复制、读写分离时的数据传输）。

### 1.4.2 架构优化
1. 主从复制 + 读写分离
2. 缓存架构（减少数据库访问）
3. 负载均衡与高可用
	- 数据库集群：用 MGR（MySQL Group Replication）搭建多主集群，支持自动故障转移。
	- 负载均衡：用 ProxySQL、HAProxy 分发数据库连接，避免单节点压力过大。

## 1.5 配置优化（基于 MySQL 配置文件 my.cnf）
- 内存配置（InnoDB 核心）：
    - `innodb_buffer_pool_size`：缓存表数据和索引，建议设为物理内存的 50%-70%（如 16G 内存设为 10G），避免内存不足导致频繁磁盘 IO。
    - `innodb_log_buffer_size`：事务日志缓存，默认 16M，高写入场景（如秒杀）可设为 64M-128M，减少日志刷盘次数。
- 连接配置：
    - `max_connections`：最大连接数，默认 151，根据业务调整（如电商峰值设为 1000），避免连接耗尽。
    - `wait_timeout`：空闲连接超时时间，默认 8 小时，设为 300 秒（5 分钟），释放闲置连接。
- 写入优化：
    - `innodb_flush_log_at_trx_commit`：事务日志刷盘策略，1 = 每次事务刷盘（最安全，性能低），2 = 每秒刷盘（兼顾安全和性能），0 = 依赖系统刷盘（性能最高，风险高）。
    - `sync_binlog`：二进制日志刷盘策略，1 = 每次事务刷盘（主从复制一致性最高），100 = 每 100 事务刷盘（性能更高）。
- 其他配置：
    - `innodb_read_io_threads`/`innodb_write_io_threads`：IO 线程数，默认 4，SSD 硬盘可设为 8-16，提升 IO 并发。
	- `query_cache_type`：查询缓存（MySQL 8.0 已移除），高写入场景建议关闭（缓存失效频繁，反而耗性能）。

## 1.6 总结
**优先级**：SQL / 索引优化 → 表结构优化 → 配置优化 → 缓存架构 → 分库分表 → 集群架构（从低成本到高成本）。

- 索引优化：
	- 针对高频查询条件创建索引，并且遵循「最左前缀原则」
	- 用覆盖索引避免回表
	- 优化索引结构：减少索引大小，去掉无用索引，使用有序字段作为索引
	- 避免索引失效：避免函数操作索引、!=、or 连接非索引字段等
- SQL优化：
	- 避免 `SELECT *`
	- 大数据量分页改用「主键过滤」
	- 批量操作：例如不要一条一条插入数据，而是批量插入。但注意不要一次性操作过多行
	- 用 `JOIN` 替代子查询，且遵循「小表驱动大表」。
- 事务优化：
	- 控制事务粒度：拆分大事务为小事务
	- 避免事务内包含非数据库操作
- 锁优化：
	- 所有 `UPDATE/DELETE` 语句的 `WHERE` 条件必须命中索引
	- 减少锁持有时间：把最可能造成锁冲突、最可能影响并发度的锁尽量往后放
	- 避免死锁：统一资源申请顺序，所有事务按相同顺序访问资源。如更新多行时，按 ID 升序更新
- 表结构设计优化
	- 字段类型「最小化 + 精准化」：例如年龄用TINYINT UNSIGNED
	- 避免大字段，可拆分到独立表
- 架构优化：
	- 主从复制 + 读写分离
	- 缓存
	- 分库分表：大数据量、大并发
- 硬件优化：内存、磁盘、CPU、网络

# 2 如何分析SQL执行的好坏
## 2.1 先明确：评价 SQL 执行好坏的核心指标
一个 “好 SQL” 需在以下维度均表现优异，而非单一维度最优：

| 指标类型      | 核心关注点                            | 判断标准（示例）                                   |
| --------- | -------------------------------- | ------------------------------------------ |
| **执行效率**  | 响应时间（冷 / 热缓存下）、执行稳定性（无长尾延迟）      | 热缓存下高频查询 <100ms，低频大查询 < 1s；无 “偶尔慢 10 倍” 现象 |
| **资源消耗**  | CPU、内存、磁盘 IO（物理读 / 逻辑读）、网络 IO    | 避免大量物理读（磁盘 IO 是性能瓶颈）、CPU 使用率不突增            |
| **并发性能**  | 锁等待时间、事务冲突率、行锁范围                 | 锁等待时间 <10ms，无大量 “锁超时”；仅锁定必要行 / 表           |
| **资源利用率** | 索引命中率、扫描行数 / 返回行数比、临时表 / 文件排序使用率 | 索引命中率 > 90%；扫描行数 / 返回行数≤10（过滤效率高）          |
| **稳定性**   | 执行计划是否稳定、数据量增长后是否仍高效             | 不会因数据量翻倍而执行时间呈指数级增长                        |

## 2.2 核心分析步骤：从 “看计划” 到 “定位瓶颈”
MySQL使用`EXPLAIN + SQL语句`（预估计划）；`EXPLAIN ANALYZE + SQL`（8.0.18+，实际执行后返回真实计划）
核心字段解读：
- **type（访问类型）**：从好到坏排序：`system > const > eq_ref > ref > range > index > ALL`
    - 「好信号」：`const`（单值匹配，如主键查询）、`eq_ref`（联表时主键 / 唯一索引匹配）、`ref`（普通索引匹配）、`range`（索引范围查询，如`between`/`in`）；
    - 「坏信号」：`ALL`（全表扫描，大表必慢）、`index`（扫描全索引树，比全表扫略好但仍低效）。
- **key（使用的索引）**：为空表示 “未命中索引”，需检查是否有合适索引或索引失效（如隐式类型转换、模糊查询前缀通配`%xxx`）。
- **rows（预估扫描行数）**：越接近 “实际返回行数” 越好，若扫描行数是返回行数的 10 倍以上，说明过滤条件低效（如`where status=1`但`status`字段重复值过多，无索引）。
- **Extra（额外操作）**：
    - 「好信号」：`Using index`（覆盖索引，无需回表，最优）、`Using where`（存储引擎层过滤数据，高效）；
    - 「坏信号」：`Using filesort`（磁盘排序，需优化`order by`/`group by`）、`Using temporary`（创建临时表，如无索引的`group by`，极慢）、`Using join buffer`（联表时无索引，用内存缓冲，大表必卡）。

## 2.3 常见 “坏 SQL” 的典型特征（快速避坑）
1. **全表扫描（大表）**：`type=ALL`，无合适索引或索引失效（如隐式类型转换：`where id='123'`（字符串）vs `id=123`（数字））；
2. **过度扫描**：扫描行数远大于返回行数（如`select * from user where age>18`，`age`无索引，扫描 10 万行返回 8 万行，需建`age`索引）；
3. **不必要的排序 / 临时表**：`Extra`出现`Using filesort`/`Using temporary`（如`group by`无索引、`order by`字段不在索引中）；
4. **联表无索引**：多表`join`时，关联字段无索引（导致`Using join buffer`，大表联表必慢）；
5. **SELECT \***：未使用覆盖索引，需回表查询（如`select id,name from user`可走`idx_id_name`覆盖索引，`select *`需回表查所有字段）；
6. **复杂子查询 / 嵌套查询**：如`in`嵌套多层子查询，可改为`join`优化（子查询可能导致优化器无法选择最优计划）；
7. **长事务 + 大范围查询**：如事务中执行`select * from order`（全表扫），锁定大量行，导致并发冲突；
8. **重复计算**：如频繁执行`count(*)`统计大表数据，未用缓存或预计算表。

## 2.4 总结
- sql指标：
	- 执行效率：耗时，长尾延迟
	- CPU使用率、内存占用、磁盘IO、网络IO
	- 并发性能：锁等待时间、事务冲突率、行锁范围
	- 资源利用率：索引命中率、扫描行数 / 返回行数比、临时表 / 文件排序使用率
- explain
	- type：访问类型，all、index差劲
	- key：使用的索引
	- rows：扫描行数，越接近 “实际返回行数” 越好
	- Extra：额外操作，有没有使用覆盖索引、磁盘排序、临时表等
- 常见坏SQL：全表扫描；差劲的Extra；长事务（如大范围查询）

---
# 3 引用
2025-12-02 18:12
Status: #idea
Tags: [[云原生]]

# 1 微服务技能到底是什么
| 模块          | 核心技能（招聘方真正想要的）                                                                                     | 招聘方高频考察点                                                                                                      | Go 生态工具 / 实践                                                                                                                                                                               |
| ----------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1. 服务拆分与设计  | - 领域驱动设计（DDD）基础，能按业务边界拆分服务（如用户、订单、支付分离）<br><br>- 避免 “分布式单体”（过度拆分 / 拆分不足）<br><br>- 定义服务职责边界（高内聚低耦合） | - “你怎么判断一个服务该拆还是该合？”<br><br>- “拆分后如何解决跨服务数据一致性问题？”<br><br>- “DDD 中的聚合根、领域服务怎么用？”                              | - 实践：用 DDD 思想拆分 “用户 - 订单 - 支付” 小系统<br><br>- 工具：EventStorming（梳理业务流程）                                                                                                                       |
| 2. 服务注册与发现  | - 理解注册中心核心原理（服务注册 / 心跳 / 注销 / 查询）<br><br>- 能选择合适的注册中心（etcd/nacos/eureka）<br><br>- 解决服务发现的一致性、可用性问题 | - “etcd 和 nacos 选哪个？为什么？”<br><br>- “服务下线后，注册中心如何快速感知？”<br><br>- “Go 中怎么集成注册中心，避免重复注册？”                        | - 主流选择：etcd（Go 生态原生，一致性强）、nacos（跨语言，配置中心一体）<br><br>- 实践：用`go-micro`/`kitex`的注册中心插件，或直接调用 etcd SDK                                                                                          |
| 3. 服务通信     | - 除了基础 RPC，还懂序列化（protobuf）、协议设计（gRPC vs REST）<br><br>- 处理通信可靠性（超时、重试、幂等性）<br><br>- 跨服务调用链追踪        | - “gRPC 的流模式用过吗？什么时候用？”<br><br>- “如何设计接口保证幂等性？”<br><br>- “跨服务调用超时了怎么排查？”                                      | - 核心框架：gRPC（Go 生态首选，支持 HTTP/2、protobuf）<br><br>- 辅助：`grpc-go`（官方 SDK）、`protoc-gen-go`（代码生成）、重试用`grpc-retry`插件                                                                              |
| 4. 服务治理（核心） | - 熔断降级（避免雪崩）、限流（保护服务）<br><br>- 配置中心（动态配置，如开关、参数）<br><br>- 服务健康检查、优雅启停                              | - “熔断和降级的区别？用什么工具实现？”<br><br>- “如何设计限流策略（令牌桶 / 漏桶）？”<br><br>- “Go 服务怎么实现优雅启停？”                                | - 熔断降级：hystrix-go、go-resilience、kitex 的 circuitbreaker 插件<br><br>- 配置中心：nacos-sdk-go、etcd（存储配置）<br><br>- 限流：[golang.org/x/time/rate](https://golang.org/x/time/rate)（原生）、uber-go/ratelimit |
| 5. 数据一致性    | - 理解分布式事务问题（CAP、BASE）<br><br>- 掌握 2PC/TCC/SAGA/ 本地消息表等方案<br><br>- 跨服务数据查询（如分布式 ID、联表查询）            | - “微服务中如何保证订单创建和支付的一致性？”<br><br>- “分布式 ID 用什么方案？为什么不用 UUID？”<br><br>- “SAGA 模式怎么实现？”                          | - 分布式 ID：雪花算法（Go 实现：sonyflake）、etcd 自增<br><br>- 事务方案：本地消息表（结合 MySQL）、SAGA（用 go-saga 框架）                                                                                                    |
| 6. 网关与流量控制  | - 理解 API 网关的作用（路由、认证、限流、监控）<br><br>- 能选型和配置网关<br><br>- 处理跨域、HTTPS 等问题                              | - “为什么需要 API 网关？不用行不行？”<br><br>- “网关的限流和服务端限流有什么区别？”<br><br>- “Go 生态有哪些网关方案？”                                 | - 轻量选择：Gin + 自定义中间件（路由、认证）<br><br>- 生产级：Kong（基于 Nginx，Go 插件）、APISIX（云原生，Go 支持）<br><br>- 实践：用 Gin 做网关，集成 JWT 认证、限流中间件                                                                       |
| 7. 可观测性（运维） | - 日志收集（结构化日志）、监控告警（指标采集）<br><br>- 分布式追踪（调用链可视化）<br><br>- 问题排查（日志 / 监控 / 追踪联动）                      | - “Go 服务怎么打印结构化日志？”<br><br>- “如何监控微服务的 QPS、延迟、错误率？”<br><br>- “分布式追踪怎么实现的？”                                    | - 日志：zap（高性能结构化日志）、lumberjack（日志轮转）<br><br>- 监控：Prometheus+Grafana，暴露 metrics 用`prometheus/client_golang`<br><br>- 追踪：Jaeger，集成 gRPC 的`opentelemetry-go`插件                                 |
| 8. 部署与容器化   | - 理解微服务在 K8s 中的部署（Deployment、Service、Ingress）<br><br>- 服务编排、滚动更新、回滚<br><br>- 资源限制（CPU / 内存）        | - “K8s 中怎么暴露微服务？ClusterIP vs NodePort vs Ingress？”<br><br>- “滚动更新时如何避免服务中断？”<br><br>- “Go 服务在 K8s 中如何配置资源限制？” | - 实践：编写 Dockerfile（多阶段构建减小镜像）、K8s YAML 配置（Deployment+Service+Ingress）<br><br>- 工具：kubectl、helm（包管理）                                                                                        |


---
# 2 引用
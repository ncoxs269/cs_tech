2025-05-07 21:40
Status: #idea
Tags:


# 1 消息队列基础
## 1.1 什么是消息队列
消息队列就是存放消息的容器。
参与消息传递的双方称为 **生产者** 和 **消费者** ，生产者负责发送消息，消费者负责处理消息。

## 1.2 有什么用
1. 异步处理：消息发送后就返回结果，减少响应时间。之后系统消费消息。
2. 削峰/限流：将短时间高并发产生的消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。
3. 降低系统耦合性：下游去消息队列消费即可，不需要和其他系统有耦合。
4. 顺序保证
5. 延时/定时处理
6. 实现分布式事务

## 1.3 会带来哪些问题
- **系统可用性降低**： 系统可用性在某种程度上降低，你需要考虑MQ挂掉或其他异常情况
- **系统复杂性提高**：需要处理消息重复消费、丢失、乱序、积压等情况
- **数据一致性问题**：消费者未正确消费消息，会导致数据不一致的情况

## 1.4 性能指标
对消息队列进行性能测试的关键点包括：**消息吞吐量、延迟时间、系统资源占用、消息可靠性和容错能力**。
消息队列能够在单位时间内处理多少消息（消息吞吐量）；消息从发送者发出到接收者接受的时间（延迟时间）；在高负载情况下对CPU、内存等系统资源的占用情况；消息是否可以确保完整无误地传递、以及在遇到故障时系统的恢复能力和持续服务的能力（消息可靠性和容错能力）。

## 1.5 消息模型
### 1.5.1 队列模型
![[image-125.png]]
又叫点对点模型。一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。

### 1.5.2 主题模型
![[image-126.png]]
又叫发布订阅模型（Pub/Sub） ，使用**主题（Topic）** 作为消息通信载体，类似于**广播模式**。发布者发布一条消息，该消息通过主题传递给所有的订阅者。

## 1.6 最佳实践
### 1.6.1 重复消费
生产端为了保证消息发送成功，可能会重复推送(直到收到成功ACK)，会产生重复消息。但是一个成熟的MQ Server框架一般会想办法解决，避免存储重复消息(比如：空间换时间，存储已处理过的message_id)，给生产端提供一个幂等性的发送消息接口。
我们需要给我们的消费者实现 **幂等** ，也就是对同一个消息的处理结果，执行多少次都不变。

### 1.6.2 顺序消费
- 生产者：将同一语义下的消息放入同一个队列(比如同一个订单)，例如使用 **Hash 取模法**。
- 消费者：处理顺序消息时，应该避免并发处理可能导致顺序打乱的情况。

### 1.6.3 消息丢失
使用一个消息队列，其实就分为三大块：生产者、中间件、消费者，所以要保证消息就是保证三个环节都不能丢失数据。
- 消息生产阶段：生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。
- 消息存储阶段：RocketMQ 通过主从模式保证消息不丢。
- 消息消费阶段：消费者接收消息+消息处理之后，才回复 ack 的话，那么消息阶段的消息不会丢失。不能收到消息就回 ack，否则可能消息处理中途挂掉了，消息就丢失了。

### 1.6.4 消息堆积
产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。
如果消息生产的速率明显增加，生产者生产太快，我们可以使用一些 **限流降级** 的方法。
如果消息生产的速率没有增加，消费者消费过慢的话：
- 我们可以先检查 **是否是消费者出现了大量的消费错误** ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。
- 也可以增加多个消费者实例，不过 **同时你还需要增加每个主题的队列数量** 。

### 1.6.5 可靠性保证
- 消息持久化
- 消息确认机制：消费者在成功处理消息后，应该向消息队列发送确认（acknowledgment）。
- 消费重试策略：当消费者处理消息失败时，需要有合理的重试策略。重试多次（如 3 次）后仍然失败，可以将消息发送到死信队列。

## 1.7 选型
![[image-127.png]]

# 2 RocketMQ
## 2.1 消费模型
`RocketMQ` 中的消息模型就是按照 **主题模型** 所实现的。
我们可以理解为 **主题模型** 就是一个标准，那些中间件只不过照着这个标准去实现而已。
![[Pasted image 20250508151816.png]]
这张图中有三个角色：
- `Topic` 主题：代表一类消息，里面有多个队列。队列分布在不同的 `Broker`中，如果是集群的话，`Broker`又分布在不同的服务器中。
	多个队列是为了**提高并发能力**。
	注意，**`RocketMQ` 在主题上是无序的、它只有在队列层面才是保证有序** 的。
- `Producer Group` 生产者组：里面有多个生产者。生产者会指定主题中的某个队列发送消息。
	`Producer` 生产消息的时候会进行轮询or其他负载均衡策略，来向同一主题的不同消息队列发送消息。
- `Consumer Group` 消费者组：里面有多个消费者。一个队列只会被消费者组中的一个消费者消费。
	如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。
	一般来讲要控制 **消费者组中的消费者个数和主题中队列个数相同** 。
	Topic 为每个消费者组维护一个 **消费位移(offset)** ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。

总结：`RocketMQ` 通过**使用在一个 `Topic` 中配置多个队列并且每个队列维护每个消费者组的消费位置** 实现了 **主题模式/发布订阅模式** 。

## 2.2 架构
`RocketMQ` 技术架构中有四大角色 `NameServer`、`Broker`、`Producer`、`Consumer`：
![[Pasted image 20250508154710.png]]
- `Broker`：主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 `Broker` ，消费者从 `Broker` 拉取消息并消费。
	**一个 `Topic` 分布在多个 `Broker`上，一个 `Broker` 可以配置多个 `Topic` ，它们是多对多的关系**。
	如果某个 `Topic` 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 **尽量多分布在不同 `Broker` 上，以减轻某个 `Broker` 的压力** 。
	`Broker` **做了集群并且还进行了主从部署** ，`slave` 定时从 `master` 同步数据(同步刷盘或者异步刷盘)，如果 `master` 宕机，**则 `slave` 提供消费服务，但是不能写入消息**。
- `NameServer`：**注册中心** ，主要提供两个功能：**Broker 管理** 和 **路由信息管理** 。
	消费者和生产者从 `NameServer` 中获取路由表然后照着路由表的信息和对应的 `Broker` 进行通信(生产者和消费者定期会向 `NameServer` 去查询相关的 `Broker` 的信息)。
	`NameServer` 也做了集群部署，但是请注意它是 **去中心化** 的，也就意味着它没有主节点。
	**单个 Broker 和所有 NameServer 保持长连接** ，并且在每隔 30 秒 `Broker` 会向所有 `Nameserver` 发送心跳，心跳包含了自身的 `Topic` 配置信息。
- `Producer`：消息发布的角色，支持分布式集群方式部署。
- `Consumer`：消息消费的角色，支持分布式集群方式部署。支持以 push 推，pull 拉两种模式对消息进行消费。
	`Consumer` 可以以两种模式启动—— **广播（Broadcast）和集群（Cluster）**。广播模式下，一条消息会发送给 **同一个消费组中的所有消费者** ，集群模式下消息只会发送给一个消费者。

## 2.3 消息类别
### 2.3.1 普通消息
对消息的处理时机、处理顺序没有特别要求，就用普通消息。每个消息之间都是相互独立的，且不需要产生关联。

生命周期：
- 初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。
- 待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。
- 消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。
- 消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。
- 消息删除：RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。

### 2.3.2 延时/定时消息
定时消息仅支持在 MessageType 为 Delay 的主题内使用。
在 4.x 版本中，只支持延时消息，默认分为 18 个等级分别为：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h，也可以在配置文件中增加自定义的延时等级和时长。
在 5.x 版本中，开始支持定时消息，在构造消息时提供了 3 个 API 来指定延迟时间或定时时间。

生命周期：
- 初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。
- 定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息**单独存储在定时存储系统中**，等待定时时刻到达。
- 待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态。
- 消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。
- 消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。
- 消息删除：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。

如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。

### 2.3.3 顺序消息
顺序消息仅支持使用 MessageType 为 FIFO 的主题。
和普通消息发送相比，顺序消息发送必须要设置**消息组**。（推荐实现 MessageQueueSelector 的方式，见下文）。要保证消息的顺序性需要**单一生产者串行发送**。
单线程使用 MessageListenerConcurrently 可以顺序消费，多线程环境下使用 MessageListenerOrderly 才能顺序消费。

### 2.3.4 事务消息
事务消息支持在分布式场景下保障消息生产和本地事务的最终一致性。
简单来讲，就是将本地事务与发送消息合并在同一个事务中。在事务未提交之前，不发送订阅的消息；发送消息的动作随着事务的成功提交而发送，随着事务的回滚而取消。
当然真正地处理过程不止这么简单，包含了半消息、事务监听和事务回查等概念，下面有更详细的说明。

## 2.4 消费者类别
### 2.4.1 PushConsumer
消费消息仅仅通过消费监听器监听并返回结果，相当于消息队列推送消息给 Consumer。
PushConsumer 的消费监听器执行结果分为以下三种情况：
- 返回消费成功：以 Java SDK 为例，返回`ConsumeResult.SUCCESS`，表示该消息处理成功，服务端按照消费结果更新消费进度。
- 返回消费失败：以 Java SDK 为例，返回`ConsumeResult.FAILURE`，表示该消息处理失败，需要根据消费重试逻辑判断是否进行重试消费。

注意，消息还未处理完成，就提前返回消费成功结果。此时如果消息消费失败，RocketMQ 服务端是无法感知的，因此不会进行消费重试。

PushConsumer 严格限制了消息同步处理及每条消息的处理超时时间，适用于以下场景：
- **消息处理时间可预估**：如果不确定消息处理耗时，经常有预期之外的长时间耗时的消息，PushConsumer 的可靠性保证会频繁触发消息重试机制造成大量重复消息。
- **无异步化、高级定制场景**：PushConsumer 限制了消费逻辑的线程模型，由客户端 SDK 内部按最大吞吐量触发消息处理。该模型开发逻辑简单，但是不允许使用异步化和自定义处理流程。

### 2.4.2 SimpleConsumer
SimpleConsumer 是一种接口原子型的消费者类型，消息的获取、消费状态提交以及消费重试都是通过消费者业务逻辑主动发起调用完成。
一个例子：
```java
// 消费示例：使用 SimpleConsumer 消费普通消息，主动获取消息处理并提交。
ClientServiceProvider provider = ClientServiceProvider.loadService();
String topic = "YourTopic";
FilterExpression filterExpression = new FilterExpression("YourFilterTag", FilterExpressionType.TAG);

SimpleConsumer simpleConsumer = provider.newSimpleConsumerBuilder()
        // 设置消费者分组。
        .setConsumerGroup("YourConsumerGroup")
        // 设置接入点。
        .setClientConfiguration(ClientConfiguration.newBuilder().setEndpoints("YourEndpoint").build())
        // 设置预绑定的订阅关系。
        .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))
        // 设置从服务端接受消息的最大等待时间
        .setAwaitDuration(Duration.ofSeconds(1))
        .build();

try {
    // SimpleConsumer 需要主动获取消息，并处理。
    List<MessageView> messageViewList = simpleConsumer.receive(10, Duration.ofSeconds(30));
    messageViewList.forEach(messageView -> {
        System.out.println(messageView);
        // 消费处理完成后，需要主动调用 ACK 提交消费结果。
        try {
            simpleConsumer.ack(messageView);
        } catch (ClientException e) {
            logger.error("Failed to ack message, messageId={}", messageView.getMessageId(), e);
        }
    });
} catch (ClientException e) {
    // 如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。
    logger.error("Failed to receive message", e);
}
```

SimpleConsumer 适用于以下场景：
- **消息处理时长不可控**：如果消息处理时长无法预估，经常有长时间耗时的消息处理情况。建议使用 SimpleConsumer 消费类型，可以在消费时自定义消息的预估处理时长，若实际业务中预估的消息处理时长不符合预期，也可以通过接口提前修改。
- **需要异步化、批量消费等高级定制场景**：SimpleConsumer 在 SDK 内部没有复杂的线程封装，完全由业务逻辑自由定制，可以实现异步分发、批量消费等高级定制场景。
- **需要自定义消费速率**：SimpleConsumer 是由业务逻辑主动调用接口获取消息，因此可以自由调整获取消息的频率，自定义控制消费速率。

### 2.4.3 PullConsumer

## 2.5 消费者组和生产者组
### 2.5.1 生产者组
RocketMQ 服务端 5.x 版本开始，**生产者是匿名的**，无需管理生产者分组（ProducerGroup）；对于历史版本服务端 3.x 和 4.x 版本，已经使用的生产者分组可以废弃无需再设置，且不会对当前业务产生影响。

### 2.5.2 消费者组
消费者分组是多个消费行为一致的消费者的负载均衡分组。消费者分组不是具体实体而是一个逻辑资源。通过消费者分组实现消费性能的水平扩展以及高可用容灾。

消费者分组中的订阅关系、投递顺序性、消费重试策略是一致的。
- 订阅关系：以消费者分组的粒度管理订阅关系。
- 投递顺序性：服务端将消息投递给消费者消费时，支持顺序投递和并发投递，投递方式在消费者分组中统一配置。
- 消费重试策略： 消费者消费消息失败时的重试策略，包括重试次数、死信队列设置等。

RocketMQ 服务端 5.x 版本：上述消费者的消费行为从关联的消费者分组中统一获取，因此，同一分组内所有消费者的消费行为必然是一致的，客户端无需关注。
RocketMQ 服务端 3.x/4.x 历史版本：上述消费逻辑由消费者客户端接口定义，因此，您需要自己在消费者客户端设置时保证同一分组下的消费者的消费行为一致。

## 2.6 最佳实践
### 2.6.1 顺序消费
顺序的两个模式：
- 普通顺序是指 消费者通过 **同一个消费队列收到的消息是有顺序的** ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 `Broker` **重启情况下不会保证消息顺序性** (短暂时间) 。
- 严格顺序是指 消费者收到的 **所有消息** 均是有顺序的。严格顺序消息 **即使在异常情况下也会保证消息的顺序性** 。
如果你使用严格顺序模式，`Broker` 集群中只要有一台机器不可用，则整个集群都不可用，你还用啥？现在主要场景也就在 `binlog` 同步。
一般而言，我们的 `MQ` 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。

如果我们现在使用了 **普通顺序模式** ，有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 **三个消息会被发送到不同队列** ，因为在不同的队列此时就无法使用 `RocketMQ` 带来的队列有序特性来保证消息有序性了。
我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 **Hash 取模法** 来保证同一个订单在同一个队列中就行了。
RocketMQ 实现了两种队列选择算法，也可以自己实现
- 轮询算法：向消息指定的 topic 所在队列中依次发送消息，保证消息均匀分布，是 RocketMQ 默认队列选择算法
- 最小投递延迟算法：每次消息投递的时候统计消息投递的延迟，选择队列时优先选择消息延时小的队列：`producer.setSendLatencyFaultEnable(true);`。
- 自己继承 MessageQueueSelector 实现
```java
SendResult sendResult = producer.send(msg, new MessageQueueSelector() {
    @Override
    public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
        //从mqs中选择一个队列,可以根据msg特点选择
        return null;
    }
}, new Object());
```

### 2.6.2 复用生产者
生产者和主题是多对多的关系，支持同一个生产者向多个主题发送消息。
如果有需要发送消息到多个主题的场景，无需为每个主题都创建一个生产者。

生产者是可以重复利用的底层资源，类似数据库的连接池。因此不需要在每次发送消息时动态创建生产者，且在发送结束后销毁生产者。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。

### 2.6.3 死信队列

### 2.6.4 回溯消费

## 2.7 分布式事务


## 2.8 底层原理
### 2.8.1 高性能读写

### 2.8.2 刷盘和存储

---
# 3 引用
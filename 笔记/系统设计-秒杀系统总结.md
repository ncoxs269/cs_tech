2025-10-28 16:04
Status: #idea
Tags: [[场景题和设计题]]

# 1 极客时间总结
## 1.1 概览
高可靠系统的三个维度：高可用，一致性，高性能。
实现高可靠的架构原则：
1. 数据尽量少：请求的上传和响应数据、系统依赖的数据都要少
2. 请求数尽量少
3. 路径尽量短：极致方法是合并部署
4. 强依赖尽量少：对系统分级，高级系统尽量减少对低级系统的强依赖
5. 不要有单点：通过无状态、或冗余备份（如数据库）实现

秒杀系统关键问题：瞬时高并发。
秒杀系统的技术场景：读多写少

秒杀业务流程：秒杀 -> 下单 -> 支付
秒杀系统架构：
- ~~秒杀详情系统~~
- ~~秒杀交易系统~~
- 秒杀系统
- ~~商品、库存系统~~
- 交易系统
- 支付系统

问题：
- MQ异步下单：要注意以下消息问题
	- 消息丢失：生产端使用消息发送表和定时任务来解决
	- 重复消费：消费端使用消息处理表保证幂等消费
- 订单超时取消如何实现
	- 一个实现方法是定时任务轮询。
	- 另一个方法是使用延迟队列。下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。
		- 达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。
		- 如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。
- 缓存预热
- 加了缓存之后的三大问题：击穿、穿透、雪崩
	- 击穿：极热热点，用本地缓存或多缓存解决
	- 穿透：不存在的商品，用临时缓存解决
	- 雪崩：随机设置超时时间
- 防止用户重复秒杀
	- 前端限制：一次点击之后按钮置灰几秒钟
	- 后端限制：在redis中记录哪些用户已经秒杀过了
- 答题系统怎么抗住高并发？

## 1.2 流程
1. 选择哪些商品参与秒杀，每个商品多少库存。预热缓存（静态、动态）
2. 秒杀消息宣发，吸引用户
3. 用户报名，大致得知多少用户参与
4. 秒杀系统展示商品信息和秒杀按钮，秒杀开始前按钮置灰。这里是动静分离的地方
5. 开始后，用户点击秒杀按钮。回答验证码后，请求按时间分片，开始秒杀。秒杀请求发到秒杀系统
6. 秒杀请求达到nginx负载均衡集群，请求被分配到不同的API网关
7. API网关实现限流（IP / 用户 ID / 接口维度），以及黑名单过滤等功能
8. 服务器首先使用令牌桶限流控制流量，限流值是压测最大QPS低一些
	- 问题：这里还有必要限流吗？
9. （假设不用MQ排队请求，这样是同步请求）
	- 问题：用了MQ之后的流程
10. 热点数据限制：用商品的hash分组把请求划分成不同的队列进行处理。避免热点商品抢占了所有连接
	- 问题：怎么实现？有什么坑？
11. 防重判断：如果用户已经秒杀过了（不论成功or失败？），那么就直接返回秒杀失败
	- 问题：怎么实现？用数据库判断就很慢，需要用缓存
12. 缓存查询：先查询库存的 本地||redis 缓存，不存在再去数据库找。库存为0了就直接返回失败，否则继续往下走
	- 这里允许一定的缓存数据不一致，最坏情况就是多放了些请求
	- 本地缓存的问题是，当更新数据库时，难以让别的机器上的本地缓存失效。
		- 低效的方法
			- 弄个RPC接口，更新数据库时广播所有机器，但是这样效率低、消息丢失(RPC调用失败)问题
			- 对商品做hash分组，让某一个商品只对应一个机器，但是这样机器就有状态并且过热了，有击穿风险
		- 有效的方法：可以加一个失效中心，让它监控数据库变更并广播给所有机器。依靠消息队列能有效地传递消息
			- 问题：查查失效中心的实现？
13. 接下来是扣减库存。扣减失败返回秒杀失败，否则继续往下走
	- 扣减逻辑不复杂，比如没有复杂的 SKU 库存和总库存这种联动关系的话，那么可以直接在redis中扣减
		- 数据一致性兜底策略：redis挂了数据丢失也没关系，可以在重启时进行数据库里的订单商品数进行计算，计算出剩余库存，然后存到redis中。
		- 问题：兜底怎么实现？
	- 复杂的扣减，还是需要在mysql中扣减.。要做好排队，减少抢锁冲突，应对高并发写
		- 应用层做排队：上面步骤中的商品hash分组队列
		- 数据库层做排队：阿里的技术
14. 扣减成功，MQ异步调用订单系统生成订单。可以采用分布式通知型事务保证一致性。
	- MQ事务消息：先发送半消息，然后扣减，扣减成功发送commit，扣减失败发送rollback（防止消息丢失还需要消息表）。订单系统再commit之后可以收到消息，从而触发订单生成。订单系统需要注意消费幂等，防止重复下单。
	- 本地消息表：参见分布式-事务
15. 返回秒杀成功，以及订单链接（用户也可以在个人中心查看）
16. 用户支付完成，则秒杀彻底结束。如果一段时间没支付，超时订单取消，则继续往下走
17. 订单取消，订单系统会调用秒杀系统的RPC告知，秒杀系统恢复这个商品的库存
	- redis扣减库存，则在redis里面恢复即可
	- mysql扣减库存，则在mysql里面恢复，并且要删除缓存

## 1.3 关键技术点
### 1.3.1 高可用
#### 1.3.1.1 隔离
- 业务隔离：让商家报名，使热点已知，方便提前预热
- 系统隔离：独立系统&集群
- 数据隔离：独立数据库、独立缓存

#### 1.3.1.2 流量削峰
答题or验证码：
- 防止用户刷接口
- 让流量基于时间分片

分层过滤：
- 在浏览器和CDN拦截大部分数据读取
- 第二层前台读系统，数据走Cache，过滤无效请求（库存没有了之后的请求）
- 第三层后台写系统，做数据的二次检验，对系统做好保护和限流
- 在数据层完成数据的强一致性校验

排队：
- 消息队列承接瞬时流量，把同步请求变成异步
- 也需要保护MQ，MQ之前应该有很多层限流, 其中可以考虑加一层抢令牌。 比如说我要放100个手机用于秒杀, 那么放10000个令牌给不同的用户, 足够了。其它的抢不到令牌的, 直接返回秒杀结束。

#### 1.3.1.3 限流
限流位置：
- **客户端限流**，好处可以限制请求的发出。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。
- **服务端限流**，好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。

限流的实现手段：
- **QPS限流**：最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。
	- 常用的后端限流方法有 **漏桶算法** 和 **令牌桶算法**。
- **线程数限流**：在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。

快速失败：限流必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。
##### 1.3.1.3.1 针对性限流
可以对同一用户ID限流。但有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这时需要加同一ip限流功能。
但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。

别以为限制了用户和ip就万事大吉，有些高手甚至可以使用代理，每次都请求都换一个ip。这时可以限制请求的接口总次数。

#### 1.3.1.4 降级
它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。

#### 1.3.1.5 拒绝服务
当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2\*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。
这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。

### 1.3.2 一致性
#### 1.3.2.1 库存读的最终一致性
库存的读取（判断还有没有商品、要不要防请求进来）缓存没有必要极致追求数据的准确性，只要保证最终一致性。缓存本身为了减少数据库的压力。
最坏情况也就是多放了一些请求进来。

#### 1.3.2.2 库存扣减
库存扣减的方式：
1. 下单减库存：简单精准，但是有人可能恶意不支付。
	- 秒杀系统会用，因为秒杀下单不支付的现象是很少的
2. 付款减库存：会有库存超卖现象
3. 预扣库存：下单后库存为其保留一定的时间（如 10 分钟），超过库存将自动释放。一定程度防止恶意支付。这是业务系统常用方式
	- 但恶意买家完全可以在 10 分钟后再次下单，或者采用一次下单很多件的方式把库存减完。
	- 结合安全和反作弊的措施：
		- 给经常下单不付款的买家进行识别打标
		- 给某些类目设置最大购买件数
		- 以及对重复下单不付款的操作进行次数限制
		- ......

#### 1.3.2.3 下单和库存两个操作的事务怎么保证
背景：下单、库存操作分别是两个系统。
解决办法：
1. 两阶段提交：可以分两步来做，先创建订单但是先不生效，然后减库存，如果减库存成功后再生效订单，否则订单不生效。类似于MySQL日志的两阶段提交
2. 分布式事务

### 1.3.3 高性能
#### 1.3.3.1 性能影响因素
性能指标：
- **响应时间（Response Time，RT）**：服务器处理响应的耗时，由**CPU 执行时间**和**线程等待时间**（比如 RPC、IO 等待、Sleep、Wait 等）组成。
	- CPU 的执行真正消耗了服务器的资源，对性能影响最大
- **QPS（Query Per Second，每秒请求数）** =（1000ms / 响应时间）× 线程数量
- 线程数最佳实践：`线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量`。如果考虑超线程，还可以 x 2

发现瓶颈：
- 性能工具： JProfiler 和 Yourkit 这两个工具，它们可以列出整个请求中每个函数的 CPU 执行时间
- 压测：
	- 简单地判断 CPU 是不是瓶颈：一个办法就是看当 QPS 达到极限时，你的服务器的 CPU 使用率是不是超过了 95%。如果没有超过，那么表示 CPU 还有提升的空间，要么是有锁限制，要么是有过多的本地 I/O 等待发生。
	- 除了CPU，系统的每一个中间件, 每一台机器, 都应该有promethus监控大屏。系统到qps极限时, 查监控大屏上谁的的cpu/内存/磁盘/网络满了, 差不多就是瓶颈了。

做好应用基线：
- 比如性能基线（QPS、RT等，何时性能突然下降）、成本基线（去年双 11 用了多少台机器）、链路基线（依赖哪些关键接口，我们的系统发生了哪些变化）
- 你可以通过这些基线持续关注系统的性能，做到在代码上提升编码质量，在业务上改掉不合理的调用，在架构和调用链路上不断的改进。

#### 1.3.3.2 动静分离
动态静态分类：数据中是否含有和访问者相关的个性化数据。

静态数据
- 缓存地点要离用户近
- 让web型缓存（varnish）或CDN缓存
- 可以对URL的结果进行缓存。https协议的链接只在最外层，内部系统用http
- CDN要点
	- 离访问量大的地区近，离主站远但和主站的网络好
	- 节点容量大且数量不多，数量不多则访问量集中、命中率高
	- CDN作为二级缓存，没取到去一级缓存（web型缓存）
	- vs 浏览器。浏览器不可控，CDN可以主动失效

动态数据：
- ESI：web服务器请求动态数据，把结果插入到静态页面中返回
- CSI：浏览器自己请求动态内容，对服务器友好，适合秒杀系统

#### 1.3.3.3 热点数据
热点数据发现
- 静态热点数据：就是能够提前预测的热点数据
- 动态热点数据发现系统
	- 收集交易链路上各个环节中的中间件产品的热点Key或抓取日志，如 Nginx、缓存、RPC 服务框架等这些中间件
	- 提供订阅给其他系统

热点数据缓存
- 更新方式
	- 定时更新
	- 主动更新：用阿里metaq技术，就是数据库字段更新会产生一条消息。让一个失效中心去监控，收到更新后给缓存发送失效请求
- 一致性：缓存没有必要极致追求数据的准确性，只要保证最终一致性。缓存本身为了减少数据库的压力。
- 单点问题
	- 冗余备份：当热点数据过热时，单个缓存也撑不住，需要弄多个实例缓存一样的内容，用nginx路由。用在web型缓存中
	- 本地缓存
- **缓存预热?**

热点数据限制：对被访问商品的 ID 做一致性 Hash，在部分服务调用的地方对请求进行 Hash 分组，每个分组设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。

热点数据隔离

#### 1.3.3.4 库存扣减实现
缓存扣减：lua脚本实现原子性，**防止超卖**
- 如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话，我觉得完全可以。
- 让redis定时将库存放到mysql中备份。redis挂了数据丢失也没关系，可以在重启时进行数据库里的订单商品数进行计算，计算出剩余库存，然后存到redis中。以数据库中的数据为准就好了。
- 但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。

MySQL扣减：需要解决热点商品占满数据库连接、和高并发抢锁的问题
- 热点商品动态迁移到单独库中
- 应用层做排队：按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量。
- 数据库层做排队：应用层只能做到单机的排队，但是应用机器数本身很多，可能一个商品在很多机器上都有队列，所以这种排队方式控制并发的能力仍然有限。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。

基于数据库的乐观锁，防止超卖：
```sql
update product set stock=stock-1 where id=product and stock > 0;
```

#### 1.3.3.5 减少数据库的更新操作
有些场景（如对商品的 lastmodifytime 字段的）更新会非常频繁，在某些场景下这些多条 SQL 是可以合并的，一定时间内只要执行最后一条 SQL 就行了。

#### 1.3.3.6 TODO：数据库分库分表

### 1.3.4 用户体验
#### 1.3.4.1 异步请求怎么通知用户结果
以下方案：
1. 一是可以给前端一个查询接口，这种查询流量，因为后端完全知晓结果, 可以全部放到redis中(甚至local cache), 不会有穿透到DB的流量, 因此可以做到速度很快。缺点是服务端的请求数会增加不少。
2. 二是采用主动 push 的方式，这种就要求服务端和客户端保持连接了，服务端处理完请求主动 push 给客户端，这种方式的缺点是服务端的连接数会比较多。

异步的请求失败直接丢弃就好了，最坏的结果就是这个人没有抢到而已。

---
# 2 引用
2025-12-08 17:22
Status: #idea
Tags: [[系统设计]]

# 1 面试代码设计
## 1.1 问题
面试官：要求用代码写一个库存管理程序，不需要特别详细，给出大致流程和结构即可。要求这个程序能够在多机器上部署，支持水平扩容，支持高并发，需要用到至少3种设计模式。

## 1.2 设计思路与关键要点
### 1.2.1 架构设计
采用**无状态服务 + 分布式存储**架构，核心分层如下：
	
| 分层   | 职责                             | 技术选型（简化）         |
| ---- | ------------------------------ | ---------------- |
| 接入层  | 负载均衡、请求路由，将请求分发到任意库存服务节点       | 网关（如 Nginx）      |
| 业务层  | 库存核心逻辑（无状态），多实例部署支持水平扩容        | Go 服务（多进程 / 多机器） |
| 缓存层  | 缓存热点库存数据，降低 DB 压力，提升高并发下的响应速度  | Redis            |
| 存储层  | 持久化库存数据，分布式部署保证数据可靠性           | MySQL（分库分表）      |
| 异步层  | 处理非核心流程（如库存日志、预警通知），削峰填谷提升并发能力 | Kafka/RabbitMQ   |
| 分布式锁 | 解决高并发下库存扣减的竞态问题（防超卖）           | Redis Redlock    |


### 1.2.2 关键技术要点
- **无状态服务**：业务层不存储任何会话 / 状态数据，所有状态（库存、配置）存储在分布式缓存 / DB，新增服务节点即可扩容；
- **分布式锁**：Redis 实现分布式锁，解决多节点并发扣减库存的超卖问题；
- **缓存优先**：热点库存数据缓存到 Redis，读请求优先查缓存，写请求先更缓存再异步刷 DB；
- **异步解耦**：非核心操作（如日志、预警）通过 MQ 异步处理，提升主流程响应速度；
- **限流熔断**：可选（简化版暂不实现），防止高并发打垮服务；

### 1.2.3 设计模式选型
| 设计模式  | 应用场景                                      |
| ----- | ----------------------------------------- |
| 单例模式  | 全局配置管理器、日志管理器、数据库等中间件，保证全服务唯一实例，避免重复初始化资源 |
| 策略模式  | 库存扣减策略：区分普通商品、秒杀商品的扣减逻辑（秒杀更严格，需预扣减）       |
| 观察者模式 | 库存预警：当库存低于阈值时，通知邮件、短信、系统通知等不同观察者          |

## 1.3 核心工作流程
以**库存扣减**（最核心的高并发场景）为例，完整流程如下：
1. **初始化阶段**：
    - 加载单例配置（数据库、Redis、MQ）；
    - 初始化单例日志管理器；
    - 注册库存预警观察者（邮件、短信通知）；
2. **请求接入**：
    - 客户端扣减库存请求经网关路由到任意库存服务节点；
3. **业务处理**：
    - 根据商品类型（普通 / 秒杀），策略模式选择对应的扣减策略；
    - 获取 Redis 分布式锁，防止多节点并发扣减；
    - 检查缓存中库存是否充足，不足则直接返回失败；
    - 扣减缓存库存，异步刷写 DB；
    - 若扣减后库存低于阈值，触发观察者模式，异步发送预警通知；
    - 释放分布式锁；

## 1.4 Go 代码实现（简化版）
### 1.4.1 目录结构
inventory-manager/
├── config/      # 单例配置
├── logger/      # 单例日志
├── inventory/   # 库存核心逻辑
├── lock/        # 分布式锁
├── cache/       # Redis缓存
└── main.go      # 入口

### 1.4.2 配置管理器
单例模式。也可以用 `wire` 库实现
```go
package config

import "sync"

// 全局配置结构体
type Config struct {
	RedisAddr     string // Redis地址
	DBAddr        string // 数据库地址
	MQAddr        string // MQ地址
	WarningThreshold int  // 库存预警阈值
}

var (
	instance *Config
	once     sync.Once
)

// GetInstance 获取单例配置
func GetInstance() *Config {
	once.Do(func() {
		// 模拟从配置文件加载
		instance = &Config{
			RedisAddr:        "127.0.0.1:6379",
			DBAddr:           "127.0.0.1:3306",
			MQAddr:           "127.0.0.1:9092",
			WarningThreshold: 10, // 库存低于10触发预警
		}
	})
	return instance
}
```

### 1.4.3 日志管理器
单例模式
```go
package logger

import (
	"log"
	"os"
	"sync"
)

type Logger struct {
	*log.Logger
}

var (
	instance *Logger
	once     sync.Once
)

// GetInstance 获取单例日志
func GetInstance() *Logger {
	once.Do(func() {
		file, _ := os.OpenFile("inventory.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
		instance = &Logger{
			Logger: log.New(file, "[INVENTORY] ", log.LstdFlags),
		}
	})
	return instance
}

// Info 简化日志方法
func (l *Logger) Info(msg string) {
	l.Logger.Println("[INFO] " + msg)
}

// Error 简化日志方法
func (l *Logger) Error(msg string) {
	l.Logger.Println("[ERROR] " + msg)
}
```

### 1.4.4 核心：库存逻辑
```go
package inventory

import (
	"context"
	"fmt"
	"time"

	"inventory-manager/cache"
	"inventory-manager/config"
	"inventory-manager/lock"
	"inventory-manager/logger"
)

// -------------------------- 观察者模式：库存预警 --------------------------
// Observer 观察者接口
type Observer interface {
	Notify(sku string, stock int) // 库存预警通知
}

// EmailObserver 邮件观察者
type EmailObserver struct{}

func (e *EmailObserver) Notify(sku string, stock int) {
	logger.GetInstance().Info(fmt.Sprintf("邮件预警：商品%s库存不足，当前库存%d", sku, stock))
	// 实际场景：调用邮件发送API
}

// SmsObserver 短信观察者
type SmsObserver struct{}

func (s *SmsObserver) Notify(sku string, stock int) {
	logger.GetInstance().Info(fmt.Sprintf("短信预警：商品%s库存不足，当前库存%d", sku, stock))
	// 实际场景：调用短信发送API
}

// Subject 被观察者（库存）
type Subject struct {
	observers []Observer // 观察者列表
}

// RegisterObserver 注册观察者
func (s *Subject) RegisterObserver(o Observer) {
	s.observers = append(s.observers, o)
}

// NotifyObservers 通知所有观察者
func (s *Subject) NotifyObservers(sku string, stock int) {
	for _, o := range s.observers {
		o.Notify(sku, stock)
	}
}

// -------------------------- 策略模式：库存扣减 --------------------------
// DeductStrategy 扣减策略接口
type DeductStrategy interface {
	Deduct(ctx context.Context, sku string, num int, c *cache.RedisCache) (bool, int, error)
}

// NormalDeductStrategy 普通商品扣减策略
type NormalDeductStrategy struct{}

func (n *NormalDeductStrategy) Deduct(ctx context.Context, sku string, num int, c *cache.RedisCache) (bool, int, error) {
	// 普通商品：直接扣减缓存
	currentStock, err := c.Get(ctx, sku)
	if err != nil {
		return false, 0, err
	}
	if currentStock < num {
		return false, currentStock, fmt.Errorf("库存不足")
	}
	newStock, err := c.Decr(ctx, sku, num)
	if err != nil {
		return false, 0, err
	}
	return true, newStock, nil
}

// SecKillDeductStrategy 秒杀商品扣减策略（更严格，预扣减）
type SecKillDeductStrategy struct{}

func (s *SecKillDeductStrategy) Deduct(ctx context.Context, sku string, num int, c *cache.RedisCache) (bool, int, error) {
	// 秒杀商品：先检查是否有预扣减库存，再扣减
	currentStock, err := c.Get(ctx, sku)
	if err != nil {
		return false, 0, err
	}
	if currentStock < num {
		return false, currentStock, fmt.Errorf("秒杀库存不足")
	}
	// 秒杀额外逻辑：限制单用户扣减数量（简化版省略）
	newStock, err := c.Decr(ctx, sku, num)
	if err != nil {
		return false, 0, err
	}
	return true, newStock, nil
}

func GetDeductStrategy(sku string) DeductStrategy {
	var strategy DeductStrategy
	skuType = ... // 根据 sku 算得
	if skuType == "seckill" {
		strategy = &SecKillDeductStrategy{}
	} else {
		strategy = &NormalDeductStrategy{}
	}
	return strategy
}

// -------------------------- 库存操作 --------------------------
// QueryProcessor 查询处理器
type QueryProcessor struct {
	cache *cache.RedisCache
}

func (q *QueryProcessor) Execute(ctx context.Context, sku string) (int, error) {
	// 优先查缓存，缓存未命中查DB（简化版省略DB逻辑）
	stock, err := q.cache.Get(ctx, sku)
	if err != nil {
		return 0, fmt.Errorf("查询库存失败：%v", err)
	}
	return stock, nil
}

// DeductProcessor 扣减处理器
type DeductProcessor struct {
	cache      *cache.RedisCache
	lock       *lock.RedisLock
	subject    *Subject
	threshold  int // 预警阈值
}

func (d *DeductProcessor) Execute(ctx context.Context, sku string, num int) (bool, error) {
	// 1. 获取分布式锁（防超卖）
	lockKey := fmt.Sprintf("lock:inventory:%s", sku)
	if !d.lock.Lock(ctx, lockKey, 5*time.Second) {
		return false, fmt.Errorf("获取分布式锁失败，请重试")
	}
	defer d.lock.Unlock(ctx, lockKey)

	// 2. 执行扣减策略
	strategy := GetDeductStrategy(sku)
	success, newStock, err := d.strategy.Deduct(ctx, sku, num, d.cache)
	if err != nil {
		return false, err
	}

	// 3. 库存预警：低于阈值通知观察者
	if newStock <= d.threshold {
		d.subject.NotifyObservers(sku, newStock)
	}

	// 4. 异步刷写DB（简化版省略MQ+DB逻辑）
	go func() {
		logger.GetInstance().Info(fmt.Sprintf("异步刷写DB：商品%s库存更新为%d", sku, newStock))
	}()

	return success, nil
}

// AddProcessor 增加处理器
type AddProcessor struct {
	cache *cache.RedisCache
}

func (a *AddProcessor) Execute(ctx context.Context, sku string, num int) (int, error) {
	// 增加库存：先更缓存，异步刷DB
	currentStock, err := a.cache.Get(ctx, sku)
	if err != nil {
		return 0, fmt.Errorf("获取库存失败：%v", err)
	}
	newStock := currentStock + num
	if err := a.cache.Set(ctx, sku, newStock); err != nil {
		return 0, fmt.Errorf("增加库存失败：%v", err)
	}
	// 异步刷DB（简化版省略）
	go func() {
		logger.GetInstance().Info(fmt.Sprintf("异步刷写DB：商品%s库存增加为%d", sku, newStock))
	}()
	return newStock, nil
}
```

# 2 redis库存
## 2.1 lua脚本实现原子性
常用方案redis+lua，借助redis单线程执行+lua脚本中的逻辑，可在一次执行中顺序完成的特性达到原子性（叫排它性更准确，因为不具备回滚动作，异常情况需自己手动编码回滚）：
```lua
-- 1. 获取库存缓存key KYES[1] = hot_{itemCode-skuCode}_stock
local hot_item_stock = KYES[1]

-- 2. 获取剩余库存数量
local stock = tonumber(redis.call('get', hot_item_stock))

-- 3. 购买数量
local buy_qty = tonumber(ARGV[1])

-- 4. 如果库存小于购买数量，则返回1，表达库存不足
if stock < buy_qty then
  return 1
end

-- 5. 库存足够，更新库存数量
stock = stock - buy_qty
redis.call('set', hot_item_stock, tostring(stock))

-- 6. 扣减成功则返回2，表达库存扣减成功
return 2
```

## 2.2 幂等性和可追溯性
但脚本还有一些问题：
- 不具备幂等性，同个订单多次执行会导致重复扣减，手动回滚也无法判断是否会回滚过，会出现重复增加的问题    
- 不具备可追溯性，不知道库存被谁被哪个订单扣减了

增强后的lua脚本：
```lua
-- 1. 获取库存扣减记录缓存 key KYES[2] = hot_{itemCode-skuCode}_deduction_history
local  hot_deduction_history = KYES[2]

-- 2. 使用 Redis Cluster hash tag 保证 stock 和 history 在同一个槽
local exist = redis.call('hexists', hot_deduction_history, ARGV[2])
-- 3. 请求幂等判断,存在返回0,表达已扣减过库存
if exist == 1 then return 0 end

-- 4. 获取库存缓存key KYES[1] = hot_{itemCode-skuCode}_stock
local hot_item_stock = KYES[1]

-- 5. 获取剩余库存数量
local stock = tonumber(redis.call('get', hot_item_stock))

-- 6. 购买数量
local buy_qty = tonumber(ARGV[1])

-- 7. 如果库存小于购买数量 则返回1,表达库存不足
if stock < buy_qty then return 1 end

-- 8. 库存足够
-- 9. 1.更新库存数量
-- 10. 2.插入扣减记录 ARGV[2] = ${扣减请求唯一key} - ${扣减类型} 值为 buy_qty
stock = stock - buy_qty
redis.call('set', hot_item_stock, tostring(stock))
redis.call('hset', hot_deduction_history, ARGV[2], buy_qty)

-- 11. 如果剩余库存等于0则返回2,表达库存已为0
if stock == 0 then return 2 end

-- 12. 剩余库存不为0返回 3 表达还有剩余库存
return 3 end
```
利用Redis Cluster hash tag保证stock和history在同个槽，这样lua脚本才能正常执行。

回滚逻辑先判断hot_deduction_history里有没有 ${扣减请求唯一key}：
- 有，则执行回补逻辑，并删除唯一key
- 没有，则认定回补成功

## 2.3 防悬挂
但这个回滚逻辑仍然有问题，不能防悬挂（订单取消的回滚请求先到，扣减请求后到）。
所以可以设计两个 deduction_history，一个保存正常请求，一个保存回滚请求（正常请求和回滚请求的key是一样的）。

正常请求：
- 如果 key 不在两个 history 中，则执行
- 如果 key 在两个 history 中任意一个，则不执行

回滚请求：
- 如果 key 在正常 history 中，且不在回滚 history 中，则执行
- 如果 key 不在两个 history 中，则把 key 写入回滚 history，不执行回滚

## 2.4 高可用
运用Redis部署的高可用方案：
- 采用Redis Cluster（数据分片+ 多副本 + 同步多写 + 主从自动选举）
- 多写节点分（同城异地）多中心防止意外灾害

定期归档冷数据。定期 + 库存为0触发redis数据往DB同步。

部分头部电商采用弱缓存抗读（非库存不足，不实时更新），DB抗写的方案。该方案前提在于，通过一系列技术方案，流量落到库存已相对低且平滑了（扛得住，不用再自己实现操作原子性）。

# 3 库存管理需求
库存管理系统的核心业务需求围绕「**库存精准可控、业务流程顺畅、成本最优、风险可控**」四大目标展开，覆盖「入库 - 存储 - 出库 - 监控 - 核算 - 决策」全流程，不同行业（零售、制造、医药、食品等）会有个性化侧重，但通用核心需求可拆解为以下八大类，每类包含具体业务场景和诉求：

### 3.1.1 一、核心库存操作需求（基础功能，确保库存流转闭环）

库存的核心操作是「进、出、调、盘、改」，所有操作需满足「可追溯、无歧义、与业务联动」：

1. **入库操作**
    
    - 场景：采购到货、销售退货、生产完工、调拨入库、盘盈入库、样品入库等。
    - 核心诉求：
        - 支持关联上游单据（采购单、生产单、退货单），避免无依据入库；
        - 记录关键信息：入库仓库、货位、商品信息（SKU、名称、规格）、数量、批次 / 效期 / 序列号（按需）、操作人、入库时间、质检结果（如待质检→合格→入库）；
        - 特殊规则：部分商品需支持「分批入库」（采购单未一次到货）、「质检合格后入库」（如原材料、医药商品）。
2. **出库操作**
    
    - 场景：销售发货、采购退货、生产领料、调拨出库、盘亏出库、报废出库、样品出库等。
    - 核心诉求：
        - 支持关联上游单据（销售单、领料单、退货单），避免无依据出库；
        - 遵循出库规则：先进先出（FIFO）、临期先出（FEFO，食品 / 医药）、指定批次 / 序列号出库（高价值商品）；
        - 控制逻辑：库存不足时禁止出库（或支持「部分出库」+「欠货登记」）、冻结 / 损坏 / 过期商品禁止出库；
        - 记录关键信息：出库仓库、货位、接收方、数量、批次 / 效期 / 序列号、操作人、出库时间。
3. **库存调拨**
    
    - 场景：同一企业内多仓库 / 多货位间的库存转移（如总仓→分仓、A 货位→B 货位）。
    - 核心诉求：
        - 支持「一对一调拨」「一对多调拨」「多对一调拨」；
        - 调拨过程可跟踪（待调拨→在途→已完成），在途库存需单独标识（避免重复占用）；
        - 调拨后自动更新源仓库 / 货位库存（减少）和目标仓库 / 货位库存（增加），确保数据一致性。
4. **库存盘点**
    
    - 场景：定期全盘（每月 / 每季度）、临时抽盘（重点商品）、专项盘点（如库存差异排查）。
    - 核心诉求：
        - 支持「离线盘点」（导出盘点表→录入实际数量→系统比对）和「在线盘点」（实时录入实际数量）；
        - 自动生成「盘盈 / 盘亏单」，支持审核流程（避免随意调整库存）；
        - 盘点期间可控制库存操作（如冻结盘点范围内商品的出入库，或支持「动态盘点」不冻结）；
        - 记录盘点差异原因（如损耗、记账错误、丢失），支持追溯。
5. **库存调整**
    
    - 场景：盘盈盘亏调整、批次 / 效期更正、库存状态变更（正常→损坏、冻结→正常）、数量修正（如系统库存与实际不符的手动调整）。
    - 核心诉求：
        - 调整需提交申请并经审批（避免越权操作）；
        - 记录调整依据（如盘点报告、质检报告）、操作人、调整时间、原因；
        - 调整后同步更新库存成本（如盘盈盘亏影响库存价值）。

### 3.1.2 二、业务联动需求（库存与上下游系统协同，避免数据孤岛）

库存不是孤立模块，需与采购、销售、生产、物流、财务等系统深度联动，确保业务流程闭环：

1. **与采购系统联动**
    
    - 采购下单时：根据当前库存 + 安全库存 + 销售预测，生成合理采购量建议；
    - 采购到货时：自动关联采购单生成入库单，入库后更新库存，同步告知采购系统「已到货」；
    - 采购退货时：关联采购退货单生成出库单，出库后减少库存，同步财务系统处理退款。
2. **与销售系统联动**
    
    - 销售下单时：实时校验库存是否充足（支持「硬校验」- 库存不足无法下单；「软校验」- 库存不足可下单但提醒欠货）；
    - 销售下单后：支持「库存锁定」（避免同一库存被多个订单占用，超卖），订单取消时解锁库存；
    - 销售发货时：关联销售单生成出库单，出库后减少库存，同步物流系统发货信息；
    - 销售退货时：关联退货单生成入库单，入库后增加库存（需区分「可二次销售」和「不可二次销售」状态）。
3. **与生产系统联动**
    
    - 生产领料时：关联生产单生成出库单，减少原材料库存；
    - 生产完工时：关联生产单生成入库单，增加成品 / 半成品库存；
    - 生产报废时：关联生产报废单生成出库单，减少原材料 / 半成品库存。
4. **与财务系统联动**
    
    - 库存变动（入库、出库、调整）实时同步财务系统，用于成本核算（如入库增加库存资产，出库结转成本）；
    - 盘盈盘亏、报废等操作同步财务系统，生成记账凭证（如盘盈计入营业外收入，盘亏计入营业外支出）；
    - 库存成本变动（如加权平均价调整）同步财务系统，确保账实相符。

### 3.1.3 三、库存精细化管理需求（适配不同行业特性，控制风险）

不同行业对库存的「精细化程度」要求差异大，但核心是「精准追溯、按规则流转」：

1. **批次管理**
    
    - 适用行业：食品、医药、化工、电子（需跟踪原料 / 成品批次，应对质量问题召回）。
    - 诉求：支持按批次入库、出库、查询库存；记录批次相关信息（生产批次、供应商批次、生产日期）；支持「批次追溯」（从成品批次追溯到原料批次、供应商、生产单）。
2. **效期管理**
    
    - 适用行业：食品、医药、美妆（有保质期要求）。
    - 诉求：记录商品「生产日期、保质期、有效期至」；支持「临期预警」（如到期前 30 天提醒）、「过期锁定」（过期商品禁止出库）；出库时遵循「临期先出（FEFO）」规则。
3. **序列号管理**
    
    - 适用行业：高价值商品（手机、家电、设备）、医疗器械（需跟踪单个商品全生命周期）。
    - 诉求：支持按序列号入库（记录单个序列号）、出库（指定序列号发货）、查询（通过序列号查库存状态、流转记录）；支持序列号追溯（如设备售后时查入库批次、销售订单）。
4. **库存状态管理**
    
    - 核心诉求：库存需区分状态，不同状态对应不同操作规则：
        - 正常：可正常出入库；
        - 待质检：采购到货后未质检，禁止出库；
        - 冻结：因售后、质量问题临时锁定，禁止出入库；
        - 损坏 / 报废：不可销售，仅可通过「报废出库」处理；
        - 占用：已被销售订单锁定，未发货，不可被其他订单占用。
5. **多维度库存管理**
    
    - 多仓库：支持多个物理仓库（如总仓、分仓、异地仓），每个仓库独立核算库存；
    - 多货位：每个仓库内划分货位（如 A 区 - 1 排 - 2 层），精准定位库存位置，方便拣货；
    - 多单位：支持「主单位 + 辅助单位」（如箱 / 件、kg/g），自动换算（如 1 箱 = 10 件），入库 / 出库可选择任意单位。

### 3.1.4 四、库存监控与预警需求（提前规避短缺 / 积压风险）

核心是「主动提醒 + 快速响应」，避免因库存问题影响业务：

1. **安全库存预警**
    
    - 诉求：为每个商品设置「安全库存」（最低库存阈值），当库存低于阈值时，自动提醒采购部门补货；支持按仓库设置不同安全库存（如分仓安全库存低于总仓）。
2. **超储预警**
    
    - 诉求：为每个商品设置「最大库存」（最高库存阈值），当库存高于阈值时，提醒仓储部门处理（如促销、调拨），避免占用仓储空间和资金。
3. **库存积压预警**
    
    - 诉求：设置「积压周期」（如 90 天未出库），对长期未动的库存自动提醒，支持查询积压原因（如销售不畅、规格淘汰）。
4. **库存不足预警**
    
    - 诉求：销售下单时、生产领料时，若库存不足，实时提醒；支持「欠货登记」，库存补充后自动通知相关部门（如销售部安排发货）。
5. **异常异动预警**
    
    - 诉求：对库存突然大幅增减（如单日出库量是平时的 5 倍）、频繁调整（如同一商品一周内多次盘盈盘亏）自动提醒，排查是否存在操作错误或异常业务。

### 3.1.5 五、库存核算与成本管理需求（财务合规，控制成本）

库存是企业核心资产，成本核算直接影响财务报表和利润计算：

1. **库存成本核算**
    
    - 诉求：支持主流成本核算方法，满足不同行业需求：
        - 先进先出（FIFO）：适合食品、医药（效期敏感）；
        - 加权平均（移动加权 / 月末加权）：适合零售、制造（商品同质化高）；
        - 个别计价：适合高价值、独一无二的商品（如定制设备、珠宝）；
    - 要求：成本核算自动执行（如入库时更新加权平均价，出库时结转对应成本），支持成本追溯（如查询某笔出库的成本计算依据）。
2. **库存价值统计**
    
    - 诉求：实时计算库存总价值（按当前成本价 × 库存数量）；支持按仓库、商品品类、库存状态统计价值；支持导出库存价值报表（用于财务对账）。
3. **成本调整需求**
    
    - 诉求：盘盈盘亏、采购价格调整、费用分摊（如采购运费、仓储费）后，可调整库存成本；调整过程需记录，确保财务合规。

### 3.1.6 六、统计分析与决策支持需求（数据驱动优化库存策略）

核心是「从库存数据中提炼价值，帮助企业降本增效」：

1. **核心指标分析**
    
    - 库存周转率：衡量库存周转速度（周转次数 = 销售成本 / 平均库存），反映库存流动性；
    - 库存周转天数：反映库存从入库到出库的平均天数（365 / 周转率）；
    - 库存准确率：实际库存与系统库存的吻合度（用于考核仓储部门）；
    - 缺货率：因库存不足导致无法发货的订单占比。
2. **结构分析**
    
    - 库存品类分析：不同品类 / SKU 的库存占比（如 A 类商品占库存价值 80%）；
    - 库存状态分析：正常 / 冻结 / 损坏 / 积压库存的占比；
    - 仓库库存分析：各仓库的库存分布、利用率（如某分仓库存周转率远低于总仓）。
3. **预测与建议**
    
    - 销售预测：基于历史销售数据 + 当前库存，预测未来一段时间的库存需求；
    - 采购建议：结合安全库存、销售预测、在途采购量，生成最优采购计划（如「A 商品库存 50 件，安全库存 100 件，在途采购 30 件，建议再采购 20 件」）；
    - ABC 分类分析：按库存价值将商品分为 A（高价值）、B（中价值）、C（低价值）类，支持差异化管理（如 A 类商品重点监控库存）。

### 3.1.7 七、权限与合规需求（风险控制，满足监管要求）

1. **权限控制**
    
    - 操作权限：不同角色拥有不同操作权限（如入库员仅能做入库操作，管理员可审批调整单）；
    - 数据权限：不同部门 / 用户仅能查看 / 操作自己相关的库存数据（如销售部只能看与销售相关的库存，分仓只能看自己仓库的库存）；
    - 审批权限：关键操作（如库存调整、报废出库）需多级审批（如仓储主管→财务→总经理）。
2. **操作追溯**
    
    - 诉求：所有库存变动（入库、出库、调整、锁定）均记录「操作日志」，包含操作人、操作时间、操作内容、关联单据、IP 地址；支持按时间、操作人、商品等维度查询日志，满足审计要求。
3. **合规适配**
    
    - 行业合规：如医药行业需满足 GSP 认证（全程追溯、效期管理）、食品行业需满足溯源要求（批次 + 效期 + 供应商追溯）；
    - 财务合规：库存数据与财务数据一致，支持税务审计（如库存成本结转凭证可追溯）。

### 3.1.8 八、特殊场景需求（行业个性化，应对复杂业务）

1. **跨部门协作需求**
    
    - 诉求：采购、销售、仓储、财务部门共享库存数据（如销售部可实时查库存，采购部可查销售预测）；支持跨部门审批流程（如调拨单需仓储部发起、财务部审批）。
2. **应急处理需求**
    
    - 库存异常处理：如实际库存与系统库存差异过大时，支持「紧急盘点」「临时调整」；
    - 业务中断恢复：如系统故障后，支持库存数据恢复（基于操作日志），确保业务不中断。
3. **多业态适配需求**
    
    - 零售行业：支持「线上线下一体化库存」（电商平台 + 实体店共享库存，避免超卖）；
    - 制造行业：支持「原材料 - 半成品 - 成品」全流程库存管理（如半成品库存可用于后续生产）；
    - 跨境电商：支持「保税仓库存管理」（区分保税库存和非保税库存，满足海关监管）。

### 3.1.9 总结

库存管理系统的核心业务需求可概括为：「**闭环流转（进 - 出 - 调 - 盘）、精准可控（精细化管理）、联动协同（上下游系统）、风险预警（短缺 / 积压）、成本核算（财务合规）、数据驱动（决策支持）** 」。不同企业需根据行业特性（如医药需效期 / 批次，零售需线上线下一体化）、业务规模（如多仓库 vs 单仓库）、管理粒度（如序列号 vs 批次）调整需求优先级，但以上八大类是通用核心，覆盖了库存管理的全流程和核心风险点。

---
# 4 引用
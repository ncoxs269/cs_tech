2025-03-31 10:11
Status: #MOC
Tags: [[计算机基础]]

# 1 进程和线程
1. 定义：
	1. 进程是程序的一次执行过程，是系统运行程序的基本单位。因此进程是动态的，系统运行一个程序即是一个进程从创建，运行到消亡的过程。
	2. 线程是进程中的子任务。
2. 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
3. 资源开销：进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC）。
4. 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
5. 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中。

# 2 为什么需要多线程
深入到计算机底层来探讨，有两个方面：
- 单核时代： **在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率**。举个例子：当只有一个线程的时候会导致 CPU 计算时， IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50% 左右。但是当有两个线程的时候就不一样了， 当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100% 了。
- 多核时代: **多核时代多线程主要是为了提高 CPU 利用率**。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话， CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

又因为 CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、 操作系统、编译程序都做出了贡献，主要体现为:
- CPU 增加了缓存，以均衡与内存的速度差异。而这导致了**可见性**问题。
- 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异。而这导致了**原子性**问题。
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。而这导致了**有序性**问题。

# 3 并发出现问题的根源: 并发三要素
## 3.1 可见性: CPU 缓存引起
**可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到**。

举个简单的例子，看下面这段代码：
```Java
//线程1执行的代码
int i = 0;
i = 10;
 
//线程2执行的代码
j = i;
```
假若执行线程 1 的是 CPU1，执行线程 2 的是 CPU2。由上面的分析可知，当线程 1 执行 `i=10` 这句时， 会先把`i`的初始值加载到 CPU1 的高速缓存中，然后赋值为 10，那么在 CPU1 的高速缓存当中`i`的值变为 10 了， 却没有立即写入到主存当中。
此时线程 2 执行 `j = i`，它会先去主存读取`i`的值并加载到 CPU2 的缓存当中，注意此时内存当中`i`的值还是 0， 那么就会使得`j`的值为 0，而不是 10。这就是可见性问题，线程 1 对变量`i`修改了之后，线程 2 没有立即看到线程 1 修改的值。

## 3.2 原子性: 分时复用引起
**原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行**。

经典的转账问题：比如从账户 A 向账户 B 转 1000 元，那么必然包括 2 个操作：从账户 A 减去 1000元，往账户 B 加上 1000元。
试想一下，如果这 2 个操作不具备原子性，那么可能导致 A 转了 1000 元，然后因为某种原因后序操作中断，导致 B 没有收到这 1000 元。 这样会导致数据一致性被破坏。所以这 2 个操作必须要具备原子性才能保证不出现一些意外的问题。

## 3.3 有序性: 重排序引起
**有序性：即程序执行的顺序按照代码的先后顺序执行**。

举个简单的例子，看下面这段代码：
```Java
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
```
上面代码定义了一个 `int` 型变量，定义了一个 `boolean` 类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看， 语句 1 是在语句 2 前面的，那么 JVM 在真正执行这段代码的时候会保证语句 1 一定会在语句 2 前面执行吗? 不一定，为什么呢? 这里可能会发生**指令重排序（Instruction Reorder）**。

# 4 并发问题
## 4.1 死锁
### 4.1.1 什么是线程死锁
线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞， 因此程序不可能正常终止。
下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：
```Java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```
线程 A 通过 `synchronized(resource1)` 获得 `resource1` 的监视器锁，然后通过 `Thread.sleep(1000)` 让线程 A 休眠 1s， 为的是让线程 B 得到执行然后获取到 `resource2` 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源， 然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。

### 4.1.2 死锁的四个必要条件
学过操作系统的朋友都知道产生死锁必须具备以下四个条件：
- **互斥条件**：该资源任意一个时刻只由一个线程占用。
- **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不剥夺条件**: 线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- **循环等待条件**: 若干进程之间形成一种头尾相接的循环等待资源关系。

### 4.1.3 如何避免线程死锁
为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：
- 破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
- 破坏请求与保持条件：一次性申请所有的资源。
- 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

## 4.2 活锁
活锁指的是 任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 
如下图所示，在极端情况下，两个线程循环反复执行以下逻辑：线程 t1 获取 lock1 锁，线程 t2 获取到 lock2 锁  。
线程 t1 尝试获取 lock2 锁失败之后，释放掉 lock1 锁，与此同时，线程 t2 尝试获取 lock1 锁失败之后，释放掉 lock2 锁  。
然后线程 t1 和 t2 再重复执行上述逻辑，这就导致线程 t1 和 t2 一直循环加锁、尝试加锁、释放锁，我们把这种情况叫做活锁。
![[Pasted image 20250331213537.png]]

死锁和活锁的区别有两点：
1. 处于死锁状态的两个线程均处于阻塞状态，不消耗 CPU 资源。相反，处于活锁状态的两个线程，仍然在不停的执行加锁、尝试加锁、释放锁等代码逻辑，消耗 CPU 资源，比起死锁，活锁的性能损耗更大。
2. 死锁发生的概率很低，在高并发情况下，两个线程频繁竞争执行临界区，才有可能发生死锁。不过相对于死锁，活锁发生的概率更低，发生活锁，除了具备死锁发生的条件之外，还需要两个线程的执行过程非常同步，才能保证 for 循环一直不退出

为解决活锁可以引入一些随机性，例如如果检测到冲突，那么就暂停随机的一定时间进行重试。这回大大减少碰撞的可能性。典型的例子是以太网的CSMA/CD检测机制。

## 4.3 饥饿
饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求…，T2可能永远等待。
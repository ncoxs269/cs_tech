2025-10-28 11:08
Status: #idea
Tags: [[分布式]]

# 1 分布式事务总览
![[image-157.png]]
## 1.1 名词解释
1. 事务：事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性，即原子性、一致性、隔离性和持久性。
2. 本地事务：当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性。
3. 全局事务：当事务由全局事务管理器进行全局管理时成为全局事务，事务管理器负责管理全局的事务状态和参与的资源，协同资源的一致提交回滚。
4. TX协议：应用与事务管理器的接口。
5. XA协议：全局事务管理器与资源管理器的接口。XA是由X/Open组织提出的分布式事务规范。该规范主要定义了全局事务管理器和局部资源管理器之间的接口。主流的数据库产品都实现了XA接口。
6. AP：应用程序。
7. RM：资源管理器，这里可以是一个DBMS或者消息服务器管理系统，必须实现XA定义的接口。资源管理器负责控制和管理实际的资源。
8. TM：事务管理器，负责协调和管理事务，提供给AP编程接口以及管理资源管理器。事务管理器控制着全局事务，管理事务的生命周期，并且协调资源。
## 1.2 分布式事务与分布式锁的区别
分布式锁解决的是分布式资源抢占的问题；分布式事务是解决流程化提交问题。

# 2 分布式事务的基本概念
## 2.1 什么是分布式事务？
简单的说，**在分布式系统上一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务节点上，分布式事务需要保证这些小操作要么全部成功，要么全部失败**。
举个例子：在电商网站中，用户对商品进行下单，需要在订单系统中创建一条订单数据，同时需要在库存系统中修改当前商品的剩余库存数量，我们一定要保证这两步操作一定同时操作成功或失败，否则业务就会出现问题。
#### 2.1.1.1 跨库事务
跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据。笔者见过一个相对比较复杂的业务，一个业务中同时操作了9个库。
#### 2.1.1.2 分库分表
通常一个库数据量比较大或者预期未来的数据量比较大，都会进行水平拆分，也就是分库分表。如下图，将数据库B拆分成了2个库：
![[image-158.png]]
对于分库分表的情况，一般开发人员都会使用一些数据库中间件来降低 sql 操作的复杂性。
如，对于 `insert into user(id,name) values (1,"tianshouzhi"),(2,"wangxiaoxiao")`。这条 sql 是操作单库的语法，单库情况下，可以保证事务的一致性。
但是由于现在进行了分库分表，开发人员希望将1号记录插入分库1，2号记录插入分库2。所以数据库中间件要将其改写为2条sql，分别插入两个不同的分库，此时要保证两个库要不都成功，要不都失败，因此基本上所有的数据库中间件都面临着分布式事务的问题。
#### 2.1.1.3 微服务化
下图演示了一个3个服务之间彼此调用的架构：
![[image-159.png]]
## 2.2 分布式事务分类：柔性事务和刚性事务
分布式一致性问题的解决思路有两种，一种是分布式事务，一种是尽量通过业务流程避免分布式事务。分布式事务是直接解决问题，而业务规避其实通过解决出问题的地方(解决提问题的人)。其实在真实业务场景中，如果业务规避不是很麻烦，最优雅的解决方案就是业务规避。

分布式事务实现方案从类型上去分刚性事务、柔型事务：
- 刚性事务满足CAP的CP理论
- 柔性事务满足BASE理论（基本可用，最终一致）
### 2.2.1 刚性事务
刚性事务：通常无业务改造，强一致性，原生支持回滚/隔离性；低并发，适合短事务。刚性事务满足足CAP的CP理论。
由于同步阻塞，处理效率低，不适合大型网站分布式场景。

刚性事务：XA 协议（2PC、JTA、JTS）、3PC。
### 2.2.2 柔性事务
柔性事务指的是，不要求强一致性，而是要求最终一致性，允许有中间状态，也就是Base理论，换句话说，就是AP状态。
与刚性事务相比，柔性事务的特点为：有业务改造，最终一致性；高并发，适合长事务。

柔性事务分为：
- 补偿型
- 异步确保型
- 最大努力通知型。
柔型事务：TCC/FMT、Saga（状态机模式、Aop模式）、本地事务消息、消息事务（半消息）

# 3 刚性事务：XA模型、XA接口规范、XA实现
## 3.1 XA模型或者 X/Open DTP模型
X/Open国际联盟有限公司是一个欧洲基金会，它的建立是为了向UNIX环境提供标准。
X/Open DTP(Distributed Transaction Process) 是一个分布式事务模型。这个模型主要使用了**两段提交(2PC - Two-Phase-Commit)** 来保证分布式事务的完整性。在X/Open DTP(Distributed Transaction Process)模型里面，有三个角色：
- **AP**: Application，应用程序。也就是业务层。哪些操作属于一个事务，就是AP定义的。
- **RM**：Resource Manager，资源管理器。一般是数据库，也可以是其他的资源管理器，如消息队列(如JMS数据源)，文件系统等。
- **TM**: Transaction Manager，事务管理器。接收AP的事务请求，对全局事务进行管理，协调RM的处理。这个也是整个事务调度模型的核心部分。

**XA规范主要定义了(全局)事务管理器(Transaction Manager)和(局部)资源管理器(Resource Manager)之间的接口**。XA接口是双向的系统接口，在事务管理器（Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。

XA之所以需要引入事务管理器是因为，在分布式系统中，从理论上讲（参考Fischer等的论文），两台机器理论上无法达到一致的状态，需要引入一个单点进行协调。
![[image-160.png]]
## 3.2 XA协议
目前知名的数据库，如Oracle, DB2,mysql等，都是实现了XA接口的，都可以作为RM。
XA是数据库的分布式事务，强一致性，在整个过程中，数据一直处于锁住状态。即从prepare到commit、rollback的整个过程中，TM一直把持折数据库的锁，如果有其他人要修改数据库的该条数据，就必须等待锁的释放，存在长事务风险。
XA 的主要限制是：
- 必须要拿到所有数据源，而且数据源还要支持XA协议。目前MySQL中只有InnoDB存储引擎支持XA协议。
- 性能比较差，要把所有涉及到的数据都要锁定，是强一致性的，会产生长事务。
- mysql支持不理想，nosql也基本不支持

以下的函数使事务管理器可以对资源管理器进行的操作：
- xa_open,xa_close：建立和关闭与资源管理器的连接。
- xa_start,xa_end：开始和结束一个本地事务。
- xa_prepare,xa_commit,xa_rollback：预提交、提交和回滚一个本地事务。
- xa_recover：回滚一个已进行预提交的事务。
- ax_开头的函数使资源管理器可以动态地在事务管理器中进行注册，并可以对XID(TRANSACTION IDS)进行操作。
	- ax_reg,ax_unreg；允许一个资源管理器在一个TMS(TRANSACTION MANAGER SERVER)中动态注册或撤消注册。

下面是XA各个阶段的处理流程：
![[image-161.png]]
## 3.3 XA协议的分类
![[image-162.png]]
### 3.3.1 2PC/3PC协议
两阶段提交（2PC）协议是XA规范定义的 数据一致性协议。
三阶段提交（3PC）协议对 2PC协议的一种扩展。
### 3.3.2 JTA和JTS规范
作为java平台上事务规范 JTA（Java Transaction API）也定义了对XA事务的支持，JTA是基于XA架构上建模的。JTA定义了一套接口，其中约定了几种主要的角色：`TransactionManager`、`UserTransaction`、`Transaction`、`XAResource`。JTA定义了这些角色之间需要遵守的规范，如 `Transaction` 的委托给`TransactionManager` 等，并通过底层事务服务（即JTS）实现。
像很多其他的java规范一样，JTA仅仅定义了接口，具体的实现则是由供应商(如J2EE厂商)负责提供，目前JTA的实现主要由以下几种：
1. J2EE容器所提供的JTA实现(JBoss)
2. 独立的JTA实现:如JOTM，Atomikos.

JTS也是一组规范，上面提到JTA中需要角色之间的交互，那应该如何交互？JTS就是约定了交互细节的规范。总体上来说JTA更多的是从框架的角度来约定程序角色的接口，而JTS则是从具体实现的角度来约定程序角色之间的接口，两者各司其职。
## 3.4 XA协议的实现
### 3.4.1 2PC（标准XA模型）
绝大部分关系型数据库，都是基于2PC完成分布式的事务处理。
顾名思义，2PC分为两个阶段处理：
1. 阶段一：提交事务请求
2. 阶段二：
	1. 阶段一正常，则执行事务提交
	2. 如果阶段一超时或者出现异常，则中断事务
#### 3.4.1.1 执行流程
##### 3.4.1.1.1 阶段一：提交事务请求
1. 事务问询：协调者向所有参与者发送事务内容，询问是否可以执行提交操作，并开始等待各参与者进行响应；
2. 执行事务：各参与者节点，执行事务操作，并将Undo和Redo操作计入本机事务日志；
3. 反馈问询：各参与者向协调者反馈事务问询的响应。成功执行返回Yes，否则返回No。
##### 3.4.1.1.2 阶段二：执行事务提交
协调者在阶段二决定是否最终执行事务提交操作。这一阶段包含两种情形：
1. **执行事务提交：所有参与者reply Yes，那么执行事务提交。**
	1. 发送提交请求：协调者向所有参与者发送Commit请求；
	2. 事务提交：参与者收到Commit请求后，会正式执行事务提交操作，并在完成提交操作之后，释放在整个事务执行期间占用的资源；
	3. 反馈提交结果：参与者在完成事务提交后，写协调者发送Ack消息确认；
	4. 完成事务：协调者在收到所有参与者的Ack后，完成事务。
![[image-164.png]]

2. **中断事务：事情总会出现意外，当存在某一参与者向协调者发送No响应，或者等待超时，协调者只要无法收到所有参与者的Yes响应，就会中断事务。**
	1. 发送回滚请求：协调者向所有参与者发送Rollback请求；
	2. 回滚：参与者收到请求后，利用本机Undo信息，执行Rollback操作。并在回滚结束后释放该事务所占用的系统资源；
	3. 反馈回滚结果：参与者在完成回滚操作后，向协调者发送Ack消息；
	4. 中断事务：协调者收到所有参与者的回滚Ack消息后，完成事务中断。
![[image-165.png]]
#### 3.4.1.2 2PC 二阶段提交的特点和优缺点
2PC 方案比较适合单体应用里，跨多个库的分布式事务。因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。

2PC 的优点在于优点主要体现在实现原理简单，缺点则比较多：
- 性能问题：2PC的提交在执行过程中，所有参与事务操作的逻辑都处于阻塞状态。也就是说，各个参与者都在等待其他参与者响应，无法进行其他操作；
- 单点故障：协调者是个单点，一旦出现问题，其他参与者将无法释放事务资源，也无法完成事务操作；
- 数据不一致。如果协调者向所有参与者发送Commit请求后发生局部网络异常，或者协调者在尚未发送完Commit请求即出现崩溃，最终导致只有部分参与者收到、执行请求。于是整个系统将会出现数据不一致的情形；
- 2PC没有完善的容错机制，当参与者出现故障时，协调者无法快速得知这一失败，只能严格依赖超时设置来决定是否进一步的执行提交还是中断事务。
### 3.4.2 3PC
针对2PC的缺点，研究者提出了3PC，即 Three-Phase Commit。3PC将原有的两阶段过程，重新划分为 **CanCommit、PreCommit 和 do Commit 三个阶段**。
#### 3.4.2.1 执行流程
![[image-166.png]]
##### 3.4.2.1.1 阶段一：CanCommit
1. 事务询问：协调者向所有参与者发送包含事务内容的canCommit的请求，询问是否可以执行事务提交，并等待应答；
2. 反馈询问：正常情况下，如果参与者认为可以顺利执行事务，则返回Yes，否则返回No。
##### 3.4.2.1.2 阶段二：PreCommit
在本阶段，协调者会根据上一阶段的反馈情况来决定是否可以执行事务的PreCommit操作。有以下两种可能：
1. **执行事务预提交**
    1. 发送预提交请求：协调者向所有节点发出PreCommit请求，并进入prepared阶段；
    2. 事务预提交：参与者收到PreCommit请求后，会执行事务操作，并将Undo和Redo日志写入本机事务日志；
    3. 反馈与提交结果：各参与者成功执行事务操作，同时将反馈以Ack响应形式发送给协调者，同事等待最终的Commit或Abort指令。
2. **中断事务**：假如任意一个参与者向协调者发送No响应，或者等待超时，协调者在没有得到所有参与者响应时，即可以中断事务：
    1. 发送中断请求：协调者向所有参与者发送Abort请求；
    2. 中断事务：收到协调者的Abort请求，**或者等待协调者请求过程中出现超时**，参与者都会中断事务；
##### 3.4.2.1.3 阶段三：doCommit
在这个阶段，会真正的进行事务提交，同样存在两种可能。
1. **执行提交**：
    1. 发送提交请求：假如协调者收到了所有参与者的Ack响应，那么将从预提交转换到提交状态，并向所有参与者，发送doCommit请求；
    2. 事务提交。参与者收到doCommit请求后，会正式执行事务提交操作，并在完成提交操作后释放占用资源；
    3. 反馈事务提交结果。参与者将在完成事务提交后，向协调者发送Ack消息；
    4. 完成事务。协调者接收到所有参与者的Ack消息后，完成事务。
2. **中断事务**：在该阶段，假设正常状态的协调者接收到任一个参与者发送的No响应，或在超时时间内，仍旧没收到反馈消息，就会中断事务。
    1. 发送中断请求。协调者向所有的参与者发送abort请求；
    2. 事务回滚。参与者收到abort请求后，会利用阶段二中的Undo消息执行事务回滚，并在完成回滚后释放占用资源；
    3. 反馈事务回滚结果。参与者在完成回滚后向协调者发送Ack消息；
    4. 中断事务。协调者接收到所有参与者反馈的Ack消息后，完成事务中断。

#### 3.4.2.2 2PC和3PC的区别
**三阶段提交协议在协调者和参与者中都引入超时机制，并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再执行**。
**在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，继续进行事务的提交**。其实这个是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了。所以，一句话概括就是，当进入第三阶段时， 由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。

相对于2PC，3PC主要解决了单点故障问题，并减少阻塞， **因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态**。
但是这种机制也会导致数据一致性问题。因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。
总结：3PC相对于2PC缓解了前两个问题，但是依然没有完全解决数据不一致的问题。
## 3.5 XA相关产品
### 3.5.1 Seata
Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式。
在 Seata 开源之前，Seata 对应的内部版本在阿里经济体内部一直扮演着分布式一致性中间件的角色，帮助经济体平稳的度过历年的双11，对各BU业务进行了有力的支撑。商业化产品GTS 先后在阿里云、金融云进行售卖。

Seata AT 模式是增强型2pc模式：两阶段提交协议的演变，没有一直锁表
- 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源
- 二阶段：提交异步化，非常快速地完成。回滚通过一阶段的回滚日志进行反向补偿
### 3.5.2 Atomikos 分布式事务实现
Atomikos公司旗下有两款著名的分布事务产品：
- TransactionEssentials：开源的免费产品
- ExtremeTransactions：商业版，需要收费
![[image-163.png]]
可以看到，在开源版本中支持JTA/XA、JDBC、JMS的事务。

# 4 柔性事务
在电商领域等互联网场景下，刚性事务在数据库性能和处理能力上都暴露出了瓶颈。
**柔性事务有两个特性：基本可用和柔性状态**。
- 基本可用是指分布式系统出现故障的时候允许损失一部分的可用性。
- 柔性状态是指允许系统存在中间状态，这个中间状态不会影响系统整体的可用性，比如数据库读写分离的主从同步延迟等。柔性事务的一致性指的是最终一致性。

柔性事务主要分为**补偿型**和**通知型**。
- 补偿型事务又分：TCC、Saga。
- 通知型事务分：MQ事务消息、最大努力通知型。

**补偿型事务都是同步的，通知型事务都是异步的**。

## 4.1 通知型事务
通知型事务的主流实现是通过 MQ（消息队列）来通知其他事务参与者自己的执行状态。
引入MQ组件，有效的将事务参与者进行解耦，各参与者都可以异步执行，所以**通知型事务又被称为异步事务**。
**通知型事务主要适用于那些需要异步更新数据，并且对数据的实时性要求较低的场景**。

通知型事务主要包含: **异步确保型事务**和**最大努力通知事务**两种。
- **异步确保型事务**：主要适用于内部系统的数据最终一致性保障，因为内部相对比较可控，如订单和购物车、收货与清算、支付与结算等等场景；
- **最大努力通知**：主要用于外部系统，因为外部的网络环境更加复杂和不可信，所以只能尽最大努力去通知实现数据最终一致性，比如充值平台与运营商、支付对接等等跨网络系统级别对接；
![[image-167.png]]
### 4.1.1 异步确保型事务
#### 4.1.1.1 MQ 事务消息方案
基于MQ的事务消息方案主要依靠MQ的**半消息机制**来实现投递消息和参与者自身本地事务的一致性保障。
半消息机制实现原理其实借鉴的2PC的思路，是二阶段提交的广义拓展。**半消息**指的是在原有队列消息执行后的逻辑，如果后面的本地逻辑出错，则不发送该消息，如果通过则告知MQ发送。
![[image-168.png]]

流程：
1. 事务发起方首先发送半消息到MQ；
2. MQ通知发送方消息发送成功；
3. 在发送半消息成功后执行本地事务；
4. 根据本地事务执行结果返回commit或者是rollback；
5. 如果消息是rollback, MQ将丢弃该消息不投递；如果是commit，MQ将会消息发送给消息订阅方；
6. 订阅方根据消息执行本地事务；
7. 订阅方执行本地事务成功后再从MQ中将该消息标记为已消费；
8. 如果执行本地事务过程中，执行端挂掉、或者超时，MQ服务器端将不停的询问执行端来获取事务状态；

##### 4.1.1.1.1 基于RocketMQ实现MQ异步确保型事务
有一些第三方的MQ是支持事务消息的，这些消息队列，支持半消息机制，比如RocketMQ，ActiveMQ。但是有一些常用的MQ也不支持事务消息，比如 RabbitMQ 和 Kafka 都不支持。
以阿里的 RocketMQ 中间件为例，其思路大致为：
1. producer(本例中指A系统)发送半消息到broker
2. broker存储半消息，半消息存储逻辑与普通消息一致，只是属性有所不同，topic是固定的`RMQ_SYS_TRANS_HALF_TOPIC`，queueId也是固定为0，这个topic中的消息对消费者是不可见的，所以里面的消息永远不会被消费。**这就保证了在半消息提交成功之前，消费者是消费不到这个半消息的**
3. broker端半消息存储成功并返回后，A系统执行本地事务，并根据本地事务的执行结果来决定半消息的提交状态为提交或者回滚
4. A系统发送结束半消息的请求，并带上提交状态(提交 or 回滚)
5. broker端收到请求后，首先从`RMQ_SYS_TRANS_HALF_TOPIC`的queue中查出该消息，设置为完成状态。如果消息状态为提交，则把半消息从`RMQ_SYS_TRANS_HALF_TOPIC`队列中复制到这个消息原始topic的queue中去(之后这条消息就能被正常消费了)；如果消息状态为回滚，则什么也不做。
6. rocketMq提供了一个兜底方案，这个方案叫消息**反查机制**，Broker启动时，会启动一个`TransactionalMessageCheckService` 任务，该任务会定时从半消息队列中读出所有超时未完成的半消息，针对每条未完成的消息，Broker会给对应的Producer发送一个消息反查请求，根据反查结果来决定这个半消息是需要提交还是回滚，或者后面继续来反查
7. consumer(本例中指B系统)消费消息，执行本地数据变更(至于B是否能消费成功，消费失败是否重试，这属于正常消息消费需要考虑的问题)

#### 4.1.1.2 本地消息表方案
有时候我们目前的MQ组件并不支持事务消息，或者我们想尽量少的侵入业务方。这时我们需要另外一种方案“基于DB本地消息表“。
本地消息表最初由eBay 提出来解决分布式事务的问题。是目前业界使用的比较多的方案之一，**它的核心思想就是将分布式事务拆分成本地事务进行处理**。
![[image-172.png]]
发送消息方：
1. 需要有一个消息表，记录着消息的相关信息。
2. 业务数据和消息表在同一个数据库，要保证它俩在同一个本地事务。直接利用本地事务，将业务数据和事务消息直接写入数据库。
3. 在本地事务中处理完业务数据和写消息表操作后，通过写消息到 MQ。
4. 注意兜底，使用定时任务将状态是“发送中”的消息重新发送。
5. 发送方通过mq接收到消费方消费成功的消息后，将消息状态设置为“成功”。

消息消费方：
1. 处理消息队列中的消息，完成自己的业务逻辑。
2. 如果本地事务处理成功，则表明已经处理成功了，再反向向mq投递一条消费成功的消息给发送方。

本地消息表优缺点：
1. 优点：
    - 本地消息表建设成本比较低，实现了可靠消息的传递，确保了分布式事务的最终一致性。
    - 无需提供回查方法，进一步减少的业务的侵入。
2. 缺点：
    - 本地消息表与业务耦合在一起，难于做成通用性，不可独立伸缩。
    - 本地消息表是基于数据库来做的，而数据库是要读写磁盘IO的，因此在高并发下是有性能瓶颈的

##### 4.1.1.2.1 MQ事务消息 VS 本地消息表
**二者的共性**：
1. 事务消息都依赖MQ进行事务通知，所以都是异步的。
**二者的区别：**
MQ事务消息：
- 需要MQ支持半消息机制或者类似特性；
- 具有比较大的业务侵入性，需要业务方进行改造，提供对应的本地操作成功的回查功能；
DB本地消息表：
- 使用了数据库来存储事务消息，降低了对MQ的要求，但是增加了存储成本；
- 事务消息使用了异步投递，增大了消息重复投递的可能性；
### 4.1.2 最大努力通知
最大努力通知方案的目标，就是最大努力将业务处理结果通知到接收方。
**最大努力通知事务**主要用于**外部系统**，因为外部的网络环境更加复杂和不可信，所以只能尽最大努力去通知实现数据最终一致性，比如充值平台与运营商、支付对接、商户通知等等跨平台、跨企业的系统间业务交互场景。
#### 4.1.2.1 MQ事务消息方案
最大努力通知事务在投递之前，跟异步确保型流程都差不多，关键在于投递后的处理。
因为异步确保型在于内部的事务处理，所以MQ和系统是直连并且无需严格的权限、安全等方面的思路设计。最大努力通知事务在于第三方系统的对接，所以最大努力通知事务有几个特性：
- 业务主动方在完成业务处理后，向业务被动方(第三方系统)发送通知消息，允许存在消息丢失。
- 业务主动方提供递增多挡位时间间隔(5min、10min、30min、1h、24h)，用于失败重试调用业务被动方的接口；在通知N次之后就不再通知，报警+记日志+人工介入。
- 业务主动方提供校对查询接口给被动方按需校对查询，用于恢复丢失的业务消息。
- 业务被动方提供幂等的服务接口，防止通知重复消费。
- 业务主动方需要有定期校验机制，对业务数据进行兜底；防止业务被动方无法履行责任时进行业务回滚，确保数据最终一致性。
#### 4.1.2.2 本地消息表方案
要实现最大努力通知，可以采用定期检查本地消息表的机制 。
![[image-175.png]]

### 4.1.3 通知型事务的问题
1. 通知型事务，是无法解决本地事务执行和消息发送的一致性问题的：因为消息发送是一个网络通信的过程，发送消息的过程就有可能出现发送失败、或者超时的情况。超时有可能发送成功了，有可能发送失败了，消息的发送方是无法确定的，所以此时消息发送方无论是提交事务还是回滚事务，都有可能不一致性出现。
2. 基于消息实现的事务并不能解决所有的业务场景，例如以下场景：某笔订单完成时，同时扣掉用户的现金。这里事务发起方是管理订单库的服务，但对整个事务是否提交并不能只由订单服务决定，因为还要确保用户有足够的钱，才能完成这笔交易，而这个信息在管理现金的服务里。

## 4.2 补偿型
针对通知型事务的问题2，这里我们可以引入基于补偿实现的事务，其流程如下：
1. 创建订单数据，但暂不提交本地事务
2. 订单服务发送远程调用到现金服务，以扣除对应的金额
3. 上述步骤成功后提交订单库的事务

以上这个是正常成功的流程，异常流程需要回滚的话，将额外发送远程调用到现金服务以加上之前扣掉的金额。

可以看到，该事务流程相对于基于消息实现的分布式事务更为复杂，需要额外开发相关的业务回滚方法，也失去了服务间流量削峰填谷的功能。
但其仅仅只比基于消息的事务复杂多一点，若不能使用基于消息队列的最终一致性事务，那么可以优先考虑使用基于补偿的事务形态。
### 4.2.1 什么是补偿模式？
**补偿模式使用一个额外的协调服务来协调各个需要保证一致性的业务服务，协调服务按顺序调用各个业务微服务。如果某个业务服务调用异常，就取消之前所有已经调用成功的业务服务**。
**补偿是一个独立的支持ACID特性的本地事务，用于在逻辑上取消服务提供者上一个ACID事务造成的影响**。对于一个长事务(long-running transaction)，与其实现一个巨大的分布式ACID事务，不如使用基于补偿性的方案，把每一次服务调用当做一个较短的本地ACID事务来处理，执行完就立即提交。

补偿模式大致有TCC、Saga 两种细分的方案。
### 4.2.2 TCC 事务模型
#### 4.2.2.1 TCC 概念
**TCC（Try-Confirm-Cancel）**的概念来源于 Pat Helland 发表的一篇名为“Life beyond Distributed Transactions:an Apostate’s Opinion”的论文。TCC 分布式事务模型包括三部分：
1. 主业务服务：主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动。
2. 从业务服务：从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作(Try)、确认操作(Confirm)、取消操作(Cancel)三个接口，供主业务服务调用。
3. 业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。

TCC 基于业务层面的事务定义，锁粒度完全由业务自己控制，目的是解决复杂业务中，跨表跨库等大颗粒度资源锁定的问题。
TCC它会弱化每个步骤中对于资源的锁定，以达到一个能承受高并发的目的（基于最终一致性）。
#### 4.2.2.2 TCC 工作流程
TCC分布式事务模型相对于 XA 等传统模型，其特征在于**它不依赖资源管理器(RM)对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务**。
TCC 模型认为对于业务系统中一个特定的业务逻辑，其对外提供服务时，必须接受一些不确定性，即对业务逻辑初步操作的调用仅是一个临时性操作，调用它的主业务服务保留了后续的取消权。每一个初步操作，最终都会被确认或取消。

TCC 分布式事务模型包括三部分：
![[image-176.png]]
1. Try阶段，尝试执行业务，完成所有业务的检查，实现一致性；预留必须的业务资源，实现准隔离性。
2. Confirm阶段：真正的去执行业务，不做任何检查，仅适用Try阶段预留的业务资源，Confirm操作还要满足幂等性。
3. Cancel阶段：取消执行业务，释放Try阶段预留的业务资源，Cancel操作要满足幂等性。

Try 阶段失败可以 Cancel，如果 Confirm 和 Cancel 阶段失败了怎么办？TCC 中会添加**事务日志**，如果 Confirm 或者 Cancel 阶段出错，则会进行**重试**，所以这两个阶段需要支持**幂等**；如果重试失败，则需要**人工介入进行恢复和处理**等。
#### 4.2.2.3 TCC 事务模型的要求
1. 可查询操作：服务操作具有全局唯一的标识，操作唯一的确定的时间。
2. 幂等操作：重复调用多次产生的业务结果与调用一次产生的结果相同。一是通过业务操作实现幂等性，二是系统缓存所有请求与处理的结果，三是检测到重复请求之后，自动返回之前的处理结果。

#### 4.2.2.4 TCC事务模型 VS DTP(XA)事务模型
![[image-177.png]]
这两张图看起来差别较大，实际上很多地方是类似的：
1. TCC模型中的主业务服务相当于 DTP模型中的AP，TCC模型中的从业务服务相当于 DTP模型中的RM
    - 不同的是DTP模型中的资源提供者是类似于Mysql这种关系型数据库，而TCC模型中资源的提供者是其他业务服务。
2. TCC模型中，从业务服务提供的try、confirm、cancel 接口相当于 DTP模型中RM提供的prepare、commit、rollback接口

TCC和2PC不同的是：
- TCC位于业务服务层而不是资源层
- 一致性和锁粒度不同：
	- XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。基于数据库锁实现，需要数据库支持XA协议，由于在执行事务的全程都需要对相关数据加锁，一般高并发性能会比较差
	- TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁，性能较好。但是对微服务的侵入性强，微服务的每个事务都必须实现try、confirm、cancel等3个方法，开发成本高，今后维护改造的成本也高。为了达到事务的一致性要求，try、confirm、cancel接口必须实现幂等性操作由于事务管理器要记录事务日志，必定会损耗一定的性能，并使得整个TCC事务时间拉长。
- 开发量不同
	- XA事务中的两阶段提交内部过程是对开发者屏蔽的，开发者从代码层面是感知不到这个过程的。而事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。
	- TCC中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在。try、confirm/cancel在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的ACID特性。

#### 4.2.2.5 TCC 的使用场景
TCC是可以解决部分场景下的分布式事务的，但是，它的一个问题在于，需要每个参与者都分别实现Try，Confirm和Cancel接口及逻辑，这对于业务的侵入性是巨大的。
TCC 方案严重依赖回滚和补偿代码，最终的结果是：回滚代码逻辑复杂，业务代码很难维护。所以，TCC 方案的使用场景较少，但是也有使用的场景。
比如说**跟钱打交道的，支付、交易相关的场景**，大家会用 TCC方案，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。

TCC实际上是最为复杂的一种情况，其能处理所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。
### 4.2.3 SAGA 长事务模型
**SAGA可以看做一个异步的、利用队列实现的补偿事务**。1987年普林斯顿大学的Hector Garcia-Molina和Kenneth Salem发表了一篇Paper Sagas，讲述的是如何处理long lived transaction（长活事务）。Saga是一个长活事务可被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务。
#### 4.2.3.1 SAGA 概念
Saga 模型是把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块（对应TCC中的Confirm和Cancel），当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终一致性。
这样的SAGA事务模型，是牺牲了一定的隔离性和一致性的，但是提高了long-running事务的可用性。
Saga 模型由三部分组成：
1. LLT（Long Live Transaction）：由一个个本地事务组成的事务链。
2. 本地事务：事务链由一个个子事务（本地事务）组成，LLT = T1+T2+T3+...+Ti。
3. 补偿：每个本地事务 Ti 有对应的补偿 Ci。

Saga的执行顺序有两种：
- T1, T2, T3, ..., Tn
- T1, T2, ..., Tj, Cj,..., C2, C1，其中0 < j < n

Saga 两种恢复策略：
- 向后恢复（Backward Recovery）：撤销掉之前所有成功子事务。如果任意本地子事务失败，则补偿已完成的事务。如异常情况的执行顺序T1,T2,T3,..Ti,Ci,...C3,C2,C1。
- 向前恢复（Forward Recovery）：即重试失败的事务，适用于必须要成功的场景，该情况下不需要Ci。执行顺序：T1,T2,...,Tj（失败）,Tj（重试）,...,Ti。

理论上补偿事务永不失败，然而，在分布式世界中，服务器可能会宕机，网络可能会失败，甚至数据中心也可能会停电。在这种情况下我们能做些什么？ **最后的手段是提供回退措施，比如人工干预**。
#### 4.2.3.2 SAGA 的使用条件
Saga看起来很有希望满足我们的需求。所有长活事务都可以这样做吗？这里有一些限制：
1. Saga只允许两个层次的嵌套，顶级的Saga和简单子事务
2. 在外层，全原子性不能得到满足。也就是说，sagas可能会看到其他sagas的部分结果
3. 每个子事务应该是独立的原子行为，在我们的业务场景下，各个业务环境（如：航班预订、租车、酒店预订和付款）是自然独立的行为，而且每个事务都可以用对应服务的数据库保证原子操作。

补偿事务从语义角度撤消了事务Ti的行为，但未必能将数据库返回到执行Ti时的状态（例如，如果事务触发导弹发射， 则可能无法撤消此操作）。
但这对我们的业务来说不是问题。其实难以撤消的行为也有可能被补偿。例如，发送电邮的事务可以通过发送解释问题的另一封电邮来补偿。
#### 4.2.3.3 SAGA 模型的解决方案
它也有半消息方案和本地消息表方案，和通知型事务的类似，只不过多了回滚操作。
#### 4.2.3.4 SAGA 的适用场景
SAGA适用于无需马上返回业务发起方最终状态的场景，例如：你的请求已提交，请稍后查询或留意通知之类。
将上述补偿事务的场景用SAGA改写，其流程如下：
- 订单服务创建最终状态未知的订单记录，并提交事务
- 现金服务扣除所需的金额，并提交事务
- 订单服务更新订单状态为成功，并提交事务

以上为成功的流程，若现金服务扣除金额失败，那么，最后一步订单服务将会更新订单状态为失败。其业务编码工作量比补偿事务多一点，包括以下内容：
- 订单服务创建初始订单的逻辑
- 订单服务确认订单成功的逻辑
- 订单服务确认订单失败的逻辑
- 现金服务扣除现金的逻辑
- 现金服务补偿返回现金的逻辑

#### 4.2.3.5 SAGA和TCC对比
**Saga相比TCC的缺点是缺少预留动作，导致补偿动作的实现比较麻烦**：Ti就是commit，比如一个业务是发送邮件，在TCC模式下，先保存草稿（Try）再发送（Confirm），撤销的话直接删除草稿（Cancel）就行了。而Saga则就直接发送邮件了（Ti），如果要撤销则得再发送一份邮件说明撤销（Ci），实现起来有一些麻烦。
如果把上面的发邮件的例子换成：A服务在完成Ti后立即发送Event到ESB（企业服务总线，可以认为是一个消息中间件），下游服务监听到这个Event做自己的一些工作然后再发送Event到ESB，如果A服务执行补偿动作Ci，那么整个补偿动作的层级就很深。

不过没有预留动作也可以认为是优点：
- 有些业务很简单，套用TCC需要修改原来的业务逻辑，而Saga只需要添加一个补偿动作就行了。
- TCC最少通信次数为2n，而Saga为n（n=sub-transaction的数量）。
- 有些第三方服务没有Try接口，TCC模式实现起来就比较tricky了，而Saga则很简单。
- 没有预留动作就意味着不必担心资源释放的问题，异常处理起来也更简单。
    

# 5 总体的方案对比

| 属性    | 2PC | TCC | Saga | 异步确保型事务 | 尽最大努力通知 |
| ----- | --- | --- | ---- | ------- | ------- |
| 事务一致性 | 强   | 弱   | 弱    | 弱       | 弱       |
| 复杂性   | 中   | 高   | 中    | 低       | 低       |
| 业务侵入性 | 小   | 大   | 小    | 中       | 中       |
| 使用局限性 | 大   | 大   | 中    | 小       | 中       |
| 性能    | 低   | 中   | 高    | 高       | 高       |
| 维护成本  | 低   | 高   | 中    | 低       | 中       |

---
# 6 引用
2025-04-27 09:39
Status: #idea
Tags: [[MySQL]]


# 1 事务隔离
**事务就是要保证一组数据库操作，要么全部成功，要么全部失败**。在 MySQL 中，**事务支持是在引擎层实现的**。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。

## 1.1 隔离性与隔离级别
提到事务，你肯定会想到 **ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）**，今天我们就来说说其中 I，也就是“隔离性”。

当数据库上有多个事务同时执行的时候，就可能出现**脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）**的问题，为了解决这些问题，就有了“隔离级别”的概念。
- 脏读：读取未提交数据。
- 不可重复读：前后多次读取，数据内容不一致。不可重复读是读取了其他事务更改的数据，**针对update操作**。
- 幻读：前后多次读取，数据总量不一致。幻读是读取了其他事务新增的数据，**针对insert和delete操作**。

**SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）**。下面我逐一为你解释：
- 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交：一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
	**可重复读不能完全防止幻读**，MVCC 会讲到。
- 串行化：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 1.1.1 视图和事务起点
在实现上，数据库里面会创建一个**视图**，访问的时候以视图的逻辑结果为准。
- “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。
- 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。
- 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。
- “串行化”隔离级别下直接用加锁的方式来避免并行访问。

`begin/start transaction` 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 `start transaction with consistent snapshot` 这个命令。

## 1.2 应用场景
我想你可能会问那什么时候需要“可重复读”的场景呢？我们来看一个数据校对逻辑的案例。
假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。
这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。

## 1.3 undo log简介
我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。
**在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作**。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。变更操作记录在 redo log，回滚操作记录在 **undo log**。

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。
![[image-29.png]]
不同时刻启动的事务会有不同的 **read-view**。同一条记录在系统中可以存在多个版本，就是数据库的**多版本并发控制（MVCC）**。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，**系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除**。什么时候才不需要了呢？就是**当系统里没有比这个回滚日志更早的 read-view 的时候**。

### 1.3.1 长事务和undo log
**长事务意味着系统里面会存在很老的事务视图，那么对应的回滚日志也是会一直存在的**。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。
在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。
**ibdata 文件是共享表空间数据文件**。 5.7 版本支持单独配置 undo log 的路径和表空间文件。一个文件在文件系统中的存放分为两个部分：数据部分和指针部分。指针位于文件系统的 meta-data 中，数据被删除后，这个指针就从 meta-data 中清除了，而数据部分存储在磁盘中。数据对应的指针从 meta-data 中清除后，文件数据部分占用的空间就可以被覆盖并写入新的内容，之所以出现“长事务最终提交，回滚段被清理，文件也不会变小”，就是因为数据库进程还在一直向这个文件写入内容，导致虽然删除了回滚段，但文件对应的指针部分由于进程锁定，并未从 meta-data 中清除，而由于指针并未被删除，那么系统内核就认为文件并未被删除，因此空间依旧占用。

**除了对回滚段的影响，长事务还占用锁资源**，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。

## 1.4 MVVC
### 1.4.1 基础概念
**MVVC (Multi-Version Concurrency Control)** (注：与 MVCC 相对的，是基于锁的并发控制，Lock-Based Concurrency Control)是一种**基于多版本的并发控制协议**，只有在 InnoDB 引擎下存在。
MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，**你可以把它当成基于多版本号的一种乐观锁**。MVCC 最大的好处，相信也是耳熟能详：**读不加锁，读写不冲突**。在读多写少的 OLTP 应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。

MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。

#### 1.4.1.1 当前读和快照读
##### 1.4.1.1.1 当前读
**它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是悲观锁的一种操作**。
如下操作都是当前读：
- select lock in share mode (共享锁)
- select for update (排他锁)
- update (排他锁)
- insert (排他锁)
- delete (排他锁)
- 串行化事务隔离级别

##### 1.4.1.1.2 快照读
快照读的实现是基于多版本并发控制，即 MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。
如下操作是快照读：
- 不加锁的 `select` 操作（注：事务级别不是串行化）

### 1.4.2 并发场景和更新丢失
#### 1.4.2.1 数据库并发场景
数据库有以下三类并发场景：
1. 读-读：不存在任何问题，也不需要并发控制。
2. 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读。
3. 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失。

#### 1.4.2.2 更新丢失
##### 1.4.2.2.1 第一类丢失更新(回滚丢失，Lost update)
A 事务撤销时，把已经提交的 B 事务的更新数据覆盖了。这种错误可能造成很严重的问题，通过下面的账户取款转账就可以看出来：
![[image-30.png]]
A 事务在撤销时，“不小心”将 B 事务已经转入账户的金额给抹去了。SQL92 没有定义这种现象，标准定义的所有隔离界别都不允许第一类丢失更新发生。

##### 1.4.2.2.2 第二类丢失更新(覆盖丢失/两次更新问题，Second lost update)
A 事务覆盖 B 事务已经提交的数据，造成 B 事务所做操作丢失：
![[image-31.png]]
第二类丢失更新，实际上和不可重复读是同一种问题。

#### 1.4.2.3 MVCC 解决并发哪些问题
解决问题如下：
- 并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。
- 解决脏读、不可重复读、幻读（都在快照读语境下）等事务隔离问题，但不能解决上面的"写-写更新丢失"问题。

因此有了下面提高并发性能的组合拳：
- MVCC + 悲观锁：MVCC 解决读写冲突，悲观锁解决写写冲突
- MVCC + 乐观锁：MVCC 解决读写冲突，乐观锁解决写写冲突

### 1.4.3 实现机制
它的实现原理主要是**版本链，undo log ，Read View** 来实现的。

#### 1.4.3.1 版本链
InnoDB 在每行数据都增加四个隐藏字段，分别是 **一个唯一行号（db_row_id），一个记录最新的事务 ID（db_trx_id），一个记录回滚的指针（db_roll_pointer），一个删除flag**。
![[image-32.png]]
下面是详细说明：
- `db_trx_id`
    6byte，最近修改(修改/插入)事务 ID：记录 创建/最后一次修改 这条记录的事务 ID。
- `db_roll_pointer`（版本链关键）
    7byte，回滚指针，指向这条记录的上一个版本（存储于 rollback segment 里）
- `db_row_id`
    6byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以 `db_row_id` 产生一个聚簇索引。
- 实际还有一个**删除 flag 隐藏字段**, 记录被删除并不代表真的删除，而是删除 flag 变了。之所以不真正的删除是因为其他事务还可能用到这些数据进行计算历史数据或回滚操作。

每次对数据库记录进行改动，都会记录一条 undo 日志，每条 undo 日志也都有一个 roll_pointer 属性（INSERT 操作对应的 undo 日志没有该属性，因为该记录并没有更早的版本），**可以将这些 undo 日志都连起来，串成一个链表**，所以现在的情况就像下图一样：
![[image-33.png]]
们把这个链表称之为**版本链，版本链的头节点就是当前记录最新的值**。另外，**每个版本中还包含生成该版本时对应的事务 ID**，这个信息很重要，在根据 Read View 判断版本可见性的时候会用到。

**注意，旧的版本并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的**。

#### 1.4.3.2 undo log
undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到 undo log 里。**当事务进行回滚时可以通过 undo log 里的日志进行数据还原**。
undo log 有以下用途：
- 保证事务进行 rollback 时的原子性和一致性，当事务进行回滚的时候可以用 undo log 的数据进行恢复。
- 用于 MVCC 快照读的数据，在MVCC 多版本控制中，通过读取 undo log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。

undo log 主要分为两种：
1. insert undo log
    代表事务在 `insert` 新记录时产生的 undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃。
2. update undo log（主要）
    事务在进行 `update` 或 `delete` 时产生的 undo log ; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除。**只有在快照读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除**。

#### 1.4.3.3 Read View(读视图)
当每个事务开启时，都会被分配一个 ID。这个 ID 是递增的，所以越新的事务，ID 值越大。
事务进行快照读操作的时候产生的**读视图(Read View)**，**在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID，也就是没有 commit 的事务。活跃事务是系统中当前不应该被本事务看到的其他事务 ID 列表**。
**Read View 主要是用来做可见性判断的**, 即当我们某个事务执行快照读的时候，把它比作条件用来判断当前事务能够看到哪个版本的数据。

Read View 有以下几个属性：
1. `trx_ids`: 当前系统活跃(未提交)事务版本号集合。
2. `low_limit_id`: 创建当前 read view 时，当前系统最大事务版本号+1。又叫**高水位**
3. `up_limit_id`: 创建当前 read view 时，系统活跃事务的最小版本号。又叫**低水位**
4. `creator_trx_id`: 创建当前 read view 的事务版本号。

Read View 可见性判断条件：
1. `db_trx_id < up_limit_id || db_trx_id == creator_trx_id`（显示）
    如果数据事务 ID 小于 Read View 中的最小活跃事务 ID，则可以肯定该数据是在当前事务启之前就已经存在了的，所以可以显示。
    或者数据的事务 ID 等于 `creator_trx_id` ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。
2. `db_trx_id >= low_limit_id`（不显示）
    如果数据事务 ID 大于 Read View 中的当前系统的最大事务 ID，则说明该数据是在当前 Read View 创建之后才产生的，所以数据不显示。如果小于则进入下一个判断。
3. `db_trx_id` 是否在活跃事务（`trx_ids`）中
    - 不存在：则说明 Read View 产生的时候事务已经 commit 了，这种情况数据则可以显示。
    - 已存在：则代表我 Read View 生成时刻，你这个事务还在活跃，还没有 commit，你修改的数据，我当前事务也是看不见的。

### 1.4.4 MVCC 和事务隔离级别
上面所讲的 Read View 用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。
- RC 隔离级别下，是**每个快照读都会生成并获取最新的 Read View**。    
- 而在 RR 隔离级别下，则是**同一个事务中的第一个快照读才会创建 Read View**, 之后的快照读获取的都是同一个Read View，之后的查询就不会重复生成了，所以一个事务的查询结果每次都是一样的。

解决幻读问题
- 快照读：通过 MVCC 来进行控制的，不用加锁。按照 MVCC 中规定的“语法”进行增删改查等操作，以避免幻读。
- 当前读：通过 **next-key 锁（行锁+gap锁）**来解决问题的。
- **需要注意，MVCC 解决的只是快照读（`select`）的幻读问题，而当前读（`update`、`insert`、`delete`）的幻读问题依靠 MVCC 无法解决**。

## 1.5 事务启动方式
MySQL 的事务启动方式有以下几种：
1. 显式启动事务语句， `begin` 或 `start transaction`。配套的提交语句是 `commit`，回滚语句是 `rollback`。
2. `set autocommit=0`，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 `select` 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 `commit` 或 `rollback` 语句，或者断开连接。
有些客户端连接框架会默认连接成功后先执行一个 `set autocommit=0` 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。

## 1.6 查询长事务
你可以在 `information_schema` 库的 `innodb_trx` 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。
```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```


---
# 2 引用
2025-04-30 11:15
Status: #idea
Tags: [[Redis]]


# 1 底层数据结构
你肯定会说：“这个我知道，不就是 **String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）** 吗？”其实，这些只是 Redis 键值对中值的数据类型，也就是数据的保存形式。而这里，我们说的数据结构，是要去看看它们的底层实现。
简单来说，**底层数据结构**一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：
![[image-114.png]]

# 2 键和值用什么结构组织？
为了实现从键到值的快速访问，**Redis 使用了一个哈希表来保存所有键值对**。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。
哈希桶中的 `entry` 元素中保存了 `*key` 和 `*value` 指针，分别指向了实际的键和值：
![[image-115.png]]

当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是**哈希表的冲突问题和 rehash 可能带来的操作阻塞**。

## 2.1 为什么哈希表操作变慢了？
Redis 解决哈希冲突的方式，就是**链式哈希**。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。
所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 `entry` 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。

## 2.2 两个全局哈希表和渐进式哈希
为了使 rehash 操作更高效，**Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2**。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：
1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。
原来的哈希表 1 留作下一次 rehash 扩容备用。

这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了**渐进式 rehash**。
在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries：
![[image-116.png]]

渐进式 rehash 执行时，除了根据键值对的操作来进行数据迁移，**Redis 本身还会有一个定时任务在执行 rehash**，如果没有键值对操作时，这个定时任务会周期性地（例如每 100ms 一次）搬移一些数据到新的哈希表中，这样可以缩短整个 rehash 的过程。

# 3 集合数据操作效率
哈希表的操作特点我们刚刚已经学过了；整数数组和双向链表也很常见，它们的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问。

## 3.1 压缩列表
压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 `zlbytes`、`zltail` 和 `zllen`，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 `zlend`，表示列表结束。
![[image-117.png]]
在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。
[压缩列表详解](https://www.cnblogs.com/chenchen0618/p/13260202.html)。

## 3.2 跳表
**跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位**，如下图所示：
![[image-118.png]]
当数据量很大时，跳表的查找复杂度就是 O(logN)。
[跳表详解。](https://blog.csdn.net/qq_33774822/article/details/106852807)

## 3.3 为什么要有整数数组和压缩列表？
两方面原因：
1. **内存利用率**，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。
2. **数组对 CPU 高速缓存支持更友好**，所以 Redis 在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。

# 4 不同操作的复杂度
我总结了一个“四句口诀”，希望能帮助你快速记住集合常见操作的复杂度。这样你在使用过程中，就可以提前规避高复杂度操作了。
1. 单元素操作是基础；
2. 范围操作非常耗时；
3. 统计操作通常高效；
4. 例外情况只有几个。

## 4.1 单元素操作
单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。例如，`Hash` 类型的 `HGET`、`HSET` 和 `HDEL`，`Set` 类型的 `SADD`、`SREM`、`SRANDMEMBER` 等。这些操作的复杂度由集合采用的数据结构决定，例如，`HGET`、`HSET` 和 `HDEL` 是对哈希表做操作，所以它们的复杂度都是 O(1)；`Set` 类型用哈希表作为底层数据结构时，它的 `SADD`、`SREM`、`SRANDMEMBER` 复杂度也是 O(1)。

集合类型支持同时对多个元素进行增删改查，例如 `Hash` 类型的 `HMGET` 和 `HMSET`，Set 类型的 `SADD` 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，`HMSET` 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。

## 4.2 范围操作
范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 `Hash` 类型的 `HGETALL` 和 `Set` 类型的 `SMEMBERS`，或者返回一个范围内的部分数据，比如 `List` 类型的 `LRANGE` 和 `ZSet` 类型的 `ZRANGE`。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。
不过，Redis 从 2.8 版本开始提供了 `SCAN` 系列操作（包括 `HSCAN`，`SSCAN` 和 `ZSCAN`），这类操作实现了**渐进式遍历**，每次只返回有限数量的数据。这样一来，相比于 `HGETALL`、`SMEMBERS` 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。

## 4.3 统计操作
统计操作，是指集合类型对集合中所有元素个数的记录，例如 `LLEN` 和 `SCARD`。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。

## 4.4 例外情况
例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 `List` 类型的 `LPOP`、`RPOP`、`LPUSH`、`RPUSH` 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。

# 5 总结
- Redis常见的数据结构有:
	- String：简单动态字符串
	- List：压缩列表（数据量小）、双向链表
	- Hash：压缩列表、哈希表
	- Set：整数数组、哈希表
	- Sorted Set：压缩列表、跳表
- Redis 整体结构是个哈希表，解决哈希冲突的方式是拉链法
	- 有两个全局哈希表，第二个用在扩容rehash时。
	- Redis 采用渐进式 rehash 扩容：每处理一个命令时都顺带着把一部分键值对移到第二个哈希表中。Redis 本身还会有一个定时任务在执行 rehash。

---
# 6 引用
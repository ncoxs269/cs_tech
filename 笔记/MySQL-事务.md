2025-04-27 09:39
Status: #idea
Tags: [[MySQL]]

# 1 事务基础
**事务就是要保证一组数据库操作，要么全部成功，要么全部失败**。在 MySQL 中，**事务支持是在引擎层实现的**。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。
事务的四大特性 **ACID**：
- **Atomicity 原子性**：事务内操作要么全部成功，要么全部失败。
- **Consistency 一致性**：事务执行前后，数据库的完整性约束（如数据规则、关系）保持不变。
- **Durability 隔离性**：多个事务并发执行时，彼此不会相互干扰，各自的执行结果独立可见。
- **Isolation 持久性**：事务一旦提交，对数据库的修改会永久保存，不受后续故障影响。

# 2 事务隔离
## 2.1 隔离性与隔离级别
当数据库上有多个事务同时执行的时候，就可能出现**脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）** 的问题，为了解决这些问题，就有了“隔离级别”的概念。
- 脏读：读取未提交数据。
- 不可重复读：前后多次读取，数据内容不一致。不可重复读是读取了其他事务更改的数据，**针对update操作**。
- 幻读：前后多次读取，数据总量不一致。幻读是读取了其他事务新增的数据，**针对insert和delete操作**。

**SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）**。下面我逐一为你解释：
- 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交：一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
	**可重复读不能完全防止幻读**，MVCC 会讲到。
- 串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 2.1.1 视图和事务起点
在实现上，数据库里面会创建一个**视图**，访问的时候以视图的逻辑结果为准。
- “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。
- 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。
- 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。
- “串行化”隔离级别下直接用加锁的方式来避免并行访问。

**`begin/start transaction` 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动**。如果你想要马上启动一个事务，可以使用 `start transaction with consistent snapshot` 这个命令。

## 2.2 可重复读应用场景
我想你可能会问那什么时候需要“可重复读”的场景呢？我们来看一个数据校对逻辑的案例。
假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。
这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。

## 2.3 undo log简介
我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。
**在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作**。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
变更操作记录在 redo log，回滚操作记录在 **undo log**。

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。
![[image-29.png]]
不同时刻启动的事务会有不同的 **read-view**。同一条记录在系统中可以存在多个版本，就是数据库的**多版本并发控制（MVCC）**。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？**系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除**。什么时候才不需要了呢？就是**当系统里没有比这个回滚日志更早的 read-view 的时候**。

### 2.3.1 长事务和undo log
**长事务意味着系统里面会存在很老的事务视图，那么对应的回滚日志也是会一直存在的**。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。
在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。
**ibdata 文件是共享表空间数据文件**。 5.7 版本支持单独配置 undo log 的路径和表空间文件。
一个文件在文件系统中的存放分为两个部分：数据部分和指针部分。指针位于文件系统的 meta-data 中，数据被删除后，这个指针就从 meta-data 中清除了。而数据部分存储在磁盘中。之所以出现“长事务最终提交，回滚段被清理，文件也不会变小”，就是因为数据库进程还在一直向这个文件写入内容，导致虽然删除了回滚段，但文件对应的指针部分由于进程锁定，并未从 meta-data 中清除。而由于指针并未被删除，那么系统内核就认为文件并未被删除，因此空间依旧占用。

**除了对回滚段的影响，长事务还占用锁资源**，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。

## 2.4 MVVC实现快照读的隔离性
### 2.4.1 基础概念
**MVVC (Multi-Version Concurrency Control)** (注：与 MVCC 相对的，是基于锁的并发控制，Lock-Based Concurrency Control)是一种**基于多版本的并发控制协议**，只有在 InnoDB 引擎下存在。
MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，**你可以把它当成基于多版本号的一种乐观锁**。MVCC 最大的好处：**读不加锁，读写不冲突**。

MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。

#### 2.4.1.1 当前读和快照读
##### 2.4.1.1.1 当前读
**它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是悲观锁的一种操作**。
如下操作都是当前读：
- select lock in share mode (共享锁)
- select for update (排他锁)
- update (排他锁)
- insert (排他锁)
- delete (排他锁)
- 读未提交、串行化隔离级别

##### 2.4.1.1.2 快照读
快照读的实现是基于 MVCC，读到的数据有可能是之前历史版本的数据。
如下操作是快照读：
- 不加锁的 `select` 操作

### 2.4.2 并发场景和更新丢失
#### 2.4.2.1 数据库并发场景
数据库有以下三类并发场景：
1. 读-读：不存在任何问题，也不需要并发控制。
2. 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读。
3. 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失。

#### 2.4.2.2 更新丢失
##### 2.4.2.2.1 第一类丢失更新(回滚丢失，Lost update)
A 事务撤销时，把已经提交的 B 事务的更新数据覆盖了。这种错误可能造成很严重的问题，通过下面的账户取款转账就可以看出来：
![[image-30.png]]
A 事务在撤销时，“不小心”将 B 事务已经转入账户的金额给抹去了。
SQL92 没有定义这种现象，标准定义的所有隔离界别都不允许第一类丢失更新发生。

##### 2.4.2.2.2 第二类丢失更新(覆盖丢失/两次更新问题，Second lost update)
A 事务覆盖 B 事务已经提交的数据，造成 B 事务所做操作丢失：
![[image-31.png]]
第二类丢失更新，实际上和不可重复读是同一种问题。

#### 2.4.2.3 MVCC 解决哪些并发场景
解决问题如下：
- 并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。
- 解决脏读、不可重复读、幻读（在快照读语境下）等事务隔离问题，**但不能解决上面的"写-写更新丢失"问题**。

因此有了下面提高并发性能的组合拳：
- MVCC + 悲观锁：MVCC 解决读写冲突，悲观锁解决写写冲突
- MVCC + 乐观锁：MVCC 解决读写冲突，乐观锁解决写写冲突

### 2.4.3 实现机制
它的实现原理主要是**版本链，undo log，Read View** 来实现的。

#### 2.4.3.1 版本链
InnoDB 在每行数据都增加四个隐藏字段，分别是 **一个唯一行号（db_row_id），一个记录最新的事务 ID（db_trx_id），一个记录回滚的指针（db_roll_pointer），一个删除flag**。
![[image-32.png]]
下面是详细说明：
- `db_trx_id`
    6byte，最近修改(修改/插入)事务 ID：记录 创建/最后一次修改 这条记录的事务 ID。
- `db_roll_pointer`（版本链关键）
    7byte，回滚指针，指向这条记录的上一个版本（存储于 rollback segment 里）
- `db_row_id`
    6byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以 `db_row_id` 产生一个聚簇索引。
- 实际还有一个**删除 flag 隐藏字段**, 记录被删除并不代表真的删除，而是删除 flag 变了。之所以不真正的删除是因为其他事务还可能用到这些数据进行计算历史数据或回滚操作。

每次对数据库记录进行改动，都会记录一条 undo 日志，每条 undo 日志也都有一个 roll_pointer 属性（INSERT 操作对应的 undo 日志没有该属性，因为该记录并没有更早的版本），**可以将这些 undo 日志都连起来，串成一个链表**，所以现在的情况就像下图一样：
![[image-33.png]]
们把这个链表称之为**版本链，版本链的头节点就是当前记录最新的值**。另外，**每个版本中还包含生成该版本时对应的事务 ID**，这个信息很重要，在根据 Read View 判断版本可见性的时候会用到。

**注意，旧的版本并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的**。

#### 2.4.3.2 undo log
undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到 undo log 里。**当事务进行回滚时可以通过 undo log 里的日志进行数据还原**。
undo log 有以下用途：
- 保证事务进行 rollback 时的原子性和一致性，当事务进行回滚的时候可以用 undo log 的数据进行恢复。
- 用于 MVCC 快照读的数据，在MVCC 多版本控制中，**通过读取 undo log 的历史版本数据**可以实现不同事务版本号都拥有自己独立的快照数据版本。

undo log 主要分为两种：
1. insert undo log
    代表事务在 `insert` 新记录时产生的 undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃。
2. update undo log（主要）
    事务在进行 `update` 或 `delete` 时产生的 undo log ; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除。**只有在快照读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除**。

#### 2.4.3.3 Read View(读视图)
当每个事务开启时，都会被分配一个 ID。这个 ID 是递增的，所以越新的事务，ID 值越大。
事务进行快照读操作的时候产生的**读视图(Read View)**，**在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID，也就是没有 commit 的事务。活跃事务是系统中当前不应该被本事务看到的其他事务 ID 列表**。
**Read View 主要是用来做可见性判断的**, 即当我们某个事务执行快照读的时候，把它比作条件用来判断当前事务能够看到哪个版本的数据。

Read View 有以下几个属性：
1. `trx_ids`: 当前系统未提交事务版本号集合。
2. `low_limit_id`: 创建当前 read view 时，当前系统最大事务版本号+1。又叫**高水位**
3. `up_limit_id`: 创建当前 read view 时，系统未提交事务的最小版本号。又叫**低水位**
4. `creator_trx_id`: 创建当前 read view 的事务版本号。

Read View 可见性判断条件：
1. `db_trx_id < up_limit_id || db_trx_id == creator_trx_id`（显示）
    如果数据事务 ID 小于 Read View 中的最小未提交事务 ID，则可以肯定该数据是在当前事务启之前就已经存在了的，所以可以显示。
    或者数据的事务 ID 等于 `creator_trx_id` ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。
2. `db_trx_id >= low_limit_id`（不显示）
    如果数据事务 ID 大于 Read View 中的当前系统的最大事务 ID，则说明该数据是在当前 Read View 创建之后才产生的，所以数据不显示。如果小于则进入下一个判断。
3. `db_trx_id` 是否在活跃事务（`trx_ids`）中
    - 不存在：则说明 Read View 产生的时候事务已经 commit 了，这种情况数据则可以显示。
    - 已存在：则代表我 Read View 生成时刻，你这个事务还在活跃，还没有 commit，你修改的数据，我当前事务也是看不见的。

### 2.4.4 MVCC 和事务隔离级别
上面所讲的 Read View 用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。
- RC 隔离级别下，是**每个快照读都会生成并获取最新的 Read View**。    
- 而在 RR 隔离级别下，则是**同一个事务中的第一个快照读才会创建 Read View**, 之后的快照读获取的都是同一个Read View，之后的查询就不会重复生成了，所以一个事务的查询结果每次都是一样的。

解决幻读问题
- 快照读：通过 MVCC 来进行控制的，不用加锁。按照 MVCC 中规定的“语法”进行增删改查等操作，以避免幻读。
- 当前读：通过 **next-key 锁（行锁+gap锁）** 来解决问题的。
- **需要注意，MVCC 解决的只是快照读（`select`）的幻读问题，而当前读（`update`、`insert`、`delete`）的幻读问题依靠 MVCC 无法解决**。
	- 例如事务A先查询ID=1的记录，这个记录不存在。然后事务B插入了ID=1的记录并且提交。然后事务A更新了ID=1的记录。最后事务A再查询ID=1的记录，发现多出了这条记录，出现幻读。

## 2.5 锁实现当前读的隔离性
InnoDB 通过 **锁** 解决 “写冲突”：
- **行锁**：针对单行数据的锁（InnoDB 默认粒度），分为：
    - 排他锁（X 锁）：事务修改数据时加 X 锁，其他事务不能加任何锁（避免同时修改）；
    - 共享锁（S 锁）：事务读取数据时可加 S 锁，其他事务可加 S 锁但不能加 X 锁（允许多读，但阻止写）。
- **表锁**：对整个表加锁（如 `LOCK TABLES t WRITE`），粒度大，性能低，一般用于 DDL 操作。
- **意向锁**：表级锁，用于 “提前声明” 事务将要加的行锁类型（如意向排他锁 IX 表示事务可能对表中某些行加 X 锁），避免表锁与行锁的冲突检查效率问题。
- **Next-Key Lock**：InnoDB 在 `REPEATABLE READ` 级别下用于防止 “幻读” 的锁，是 “行锁 + 间隙锁” 的组合（锁定记录及相邻的间隙，阻止新插入数据）。

详细参见[[MySQL-锁]]

## 2.6 总结
- 事务有三种问题：脏读(读未提交数据)、不可重复读(前后读取的内容不一致)、幻读(前后读取的条数不一致)
- 事务有四种隔离级别：读未提交、读已提交、可重复读、串行化
- 当前读和快照读：
	- 当前读读取数据的最新值，需要加锁
	- 快照读基于MVVC，读取数据可见版本的值。只有不加锁的select语句是快照读
- MVVC实现了事务快照读的隔离性，它可以理解为一种基于多版本号的乐观锁，它的好处是“读不加锁，读写不冲突”。它只在读已提交、可重复读隔离级别生效。
- InnoDB 通过锁（行锁、间隙锁、表锁）实现了事务当前读的隔离性，解决当前读的 “写冲突”。间隙锁只在可重复读生效。
- MVVC的实现机制：版本链、undo log、Read View
	- undo log：每条记录更新时会记录一条undo log，记载回滚操作。事务回滚时用 undo log 进行恢复；快照读通过最新数据+应用undo log 来获取自己版本的数据。
		- undo log何时被清理：当快照读或事务回滚不涉及该undo log时，也就是系统里没有比这个回滚日志更早的 read-view 的时候，对应的undo log才会被 purge 线程统一清除
	- 版本链：InnoDB每条记录有一个隐藏字段：回滚指针，指向它上个版本的undo log。undo log 也有回滚指针，可以将这些 undo log 连起来串成一个链表。每条 undo log 还会记录和它对应事务的ID
		- 事务ID：每个事务开启时，都会被分配一个 ID。这个 ID 是递增的，所以越新的事务，ID 值越大。
	- Read View：
		- 读已提交的每次快照读、可重复读的第一条SQL，都会开启一个Read View。它记录系统当前未提交事务的 ID，用来做可见性判断。
		- 它包含创建时候的：1）未提交事务ID集合；2）高水位，最大事务ID+1；3）低水位，未提交事务的最小ID；4）当前 read view 的事务ID。
		- 可见性判断步骤：
			1. 可见：记录事务ID < 低水位 || \== read view事务ID
			2. 不可见：记录事务ID >= 高水位
			3. 最后：不在未提交事务ID集合里，可见；否则不可见。
- MVCC 解决的只是快照读的幻读问题，而当前读依靠 MVCC 无法解决。当前读是通过 next-key 锁（行锁+gap锁） 来解决。
	- 例如事务A先查询ID=1的记录，这个记录不存在。然后事务B插入了ID=1的记录并且提交。然后事务A更新了ID=1的记录。最后事务A再查询ID=1的记录，发现多出了这条记录，出现幻读。
	- 如果有 next-key 锁，那么事务A第一次查询的时候就会加上锁，防止事务B插入。

# 3 事务的原子性
原子性要求事务 “要么全执行，要么全回滚”，核心靠 **undo log** 实现。

# 4 事务的持久性
持久性要求事务提交后，数据修改 “永久生效，不受崩溃影响”，核心靠 **redo log + 双写缓冲区（doublewrite buffer）** 保障。

redo log 参见[[MySQL-日志与主备#1 日志系统：一条SQL更新语句是如何执行的]]。

双写缓冲区解决 “部分写问题”：若数据页刷盘时崩溃（如写了一半），会导致数据页损坏，且 redo log 无法修复（因为 redo log 基于完整数据页）。
原理：数据页刷盘前，先复制到内存中的 “双写缓冲区”，再分两步写入磁盘：
1. 先将双写缓冲区的内容写入磁盘的 “双写文件”（连续空间，顺序写，快）；
2. 再将数据页从双写缓冲区写入实际数据文件。若崩溃，可从双写文件恢复完整数据页，再用 redo log 修复。

# 5 事务的一致性
## 5.1 介绍
一致性有点抽象，“完整性约束”就是数据库或业务层面定好的 “数据规矩”，常见的有这几类：
- 数据格式约束：比如年龄必须是正整数、手机号是 11 位数字。
- 逻辑关系约束：比如主键不能重复、外键必须对应另一张表的有效数据。
- 业务规则约束：比如银行账户余额不能为负、库存不能小于已下单数量。

例如银行转账。假设 A 账户有 1000 元，B 账户有 500 元，A 给 B 转 300 元，预设规矩是 “账户余额不能为负”。那么事务执行前后，不能违反“转账总金额不变” 的隐性规则。

**一致性的核心就是：事务不管成功还是失败，这些 “规矩” 都不能被打破**。
**一致性不是 “数据不变”，而是 “数据变化的过程和结果都符合规则”**。
事务的原子性、隔离性其实都是在为一致性保驾护航 —— 原子性避免 “只执行一半”，隔离性避免 “多个事务互相干扰”，最终确保数据始终处于合法状态。
## 5.2 实现方式
一致性是事务的 “终极目标”（数据符合预设规则），并非由单一技术直接实现，而是**原子性、隔离性、持久性共同作用的结果，同时依赖数据库约束机制**：主键约束（避免重复）、外键约束（关联表数据有效）、唯一约束、`CHECK` 约束（如 `age > 0`）等。

# 6 事务使用和运维
## 6.1 事务启动方式
MySQL 的事务启动方式有以下几种：
1. 显式启动事务语句， `begin` 或 `start transaction`。配套的提交语句是 `commit`，回滚语句是 `rollback`。
2. `set autocommit=0`，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 `select` 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 `commit` 或 `rollback` 语句，或者断开连接。
有些客户端连接框架会默认连接成功后先执行一个 `set autocommit=0` 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。
## 6.2 查询长事务
你可以在 `information_schema` 库的 `innodb_trx` 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。
```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```


---
# 7 引用
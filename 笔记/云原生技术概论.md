2025-04-12 10:08
Status: #idea
Tags: [[云原生]]


# 1 云计算的演进变革
**回顾历史，重点不在于考古，而是借历史之名，理解每种技术出现的原因和淘汰的原因，更好地解决今天的现实问题，寻找出未来的技术演进之路**。那么介绍云原生之前，让我们回顾一下过去几十年间云计算领域的演进历程。
**云计算是一种通过互联网提供计算资源和服务的模式**。它将计算资源、存储资源和应用程序等服务通过虚拟化技术整合在一起，并通过互联网提供给用户。用户可以根据需求随时获取和释放这些资源，而无需关心底层的硬件和基础设施。

## 1.1 物理机时代
云计算的起源最早可追溯到 60 多年前的“远古时期”。
1959 年，计算机专家 Christopher Strachey 发表《Time Sharing in Large Fast Computer》论文[1](https://www.thebyte.com.cn/architecture/history.html#footnote1)，首次提出了“虚拟化”的概念。**虚拟化正是云计算架构的核心**，是云计算发展的基础。
> [!note] 虚拟化技术
> 虚拟化技术是一种资源管理技术，在各种实体资源（CPU、内存、网络、存储等）之上构建一个逻辑层，从而摆脱物理限制的约束，提高物理资源的利用率。

不过受限于当时技术，虚拟化只是一个概念和对未来的畅想！虚拟化技术成熟之前，市场一直处于物理机时代，当时启用一个新的应用，需要购买一台物理服务器、安装操作系统、配置软件运行环境，最后托管至机房，中间过程复杂且漫长。
在物理机时代，我们看到业务的工作负载是整台物理机，操作麻烦、资源没有隔离、也完全没有服务/资源供应商一说！

## 1.2 虚拟化技术成熟
2000 年前后，虚拟化技术逐渐发展成熟。
![](https://www.thebyte.com.cn/assets/cloud-history-1-BS8KYSxV.svg)
这一时期，云计算的重要里程碑之一是，2001 年 VMware 发布了第一个针对 x86 服务器的虚拟化产品 —— VMware ESX。使用 VMware ESX 可以在一台物理机器上运行多个虚拟机，如果业务需要扩容，那就再开通一个虚拟机，操作过程只要几分钟。
**从虚拟化技术的发展中，我们看到业务的工作负载由物理机转向虚拟机，资源有了初级的隔离、分配/利用更加合理**，而且服务部署的速度和弹性也远超物理机。

## 1.3 云计算技术成熟（XaaS）
2006 年 8 月 9 日，Google 首席执行官 Eric Schmidt 在搜索引擎大会（SES San Jose 2006）首次提出“云计算”（Cloud Computing）的概念[2](https://www.thebyte.com.cn/architecture/history.html#footnote2)，而 Amazon 正是那年推出了 IaaS 服务模型的平台 AWS。
事实上，尽管“云计算”概念早在 2006 年被提出，但直到 2008 年整个行业才迎来爆发式增长，国内云计算的标杆阿里云也在这一年开始筹备。从那以后，云计算正式成为计算机领域最受关注的话题之一，同时也成为互联网公司研究及发展的重要方向。

虚拟化技术的成熟，使得云计算市场开始真正形成，基于虚拟化技术诞生了众多的云计算产品，陆续出现了 IaaS、PaaS、SaaS 以及公有云、私有云、混合云等多种云服务模型。
![](https://www.thebyte.com.cn/assets/cloud-history-2-COr1xNI1.svg)
- IaaS（Infrastructure as a Service，基础设施即服务）的出现：通过按时计费的方式租借服务器（**卖资源**），将资本支出转变为运营支出，这使得云计算得以大规模兴起和普及。
- PaaS（Platform as a Service，平台即服务）的出现：使开发者不必费心考虑操作系统和开发工具更新或者硬件维护，云服务供应商**由 IaaS 阶段的卖资源进阶为卖服务**。
- 开源 IaaS 的出现：开源云计算平台 OpenStack 简化了云的部署过程并为其带来良好的可扩展性，这使**普通的企业也具备了自建私有云的能力**，云也发展出了 自建私有云、公共云、租赁私有云及混合云等多种服务模型。
- 开源 PaaS 的出现：开源应用平台 Cloud Foundry、OpenShift 能**在混合云、多云乃至边缘的跨平台环境中一致地加快开发和交付应用**。利用这些开源软件，企业内部参差不齐的云架构系统，被“推着”成为行业“先进”水准。
- FaaS（Function as a Service，功能即服务）的出现：通过 FaaS，物理硬件、虚拟机操作系统和 Web 服务器软件管理等等全部由云服务供应商自动处理。**无服务器（Serverless）的概念初现，开发者将无需再关注任何服务、资源等基础设施**。
![|700x245](https://www.thebyte.com.cn/assets/xaas-DeUvn0Gb.svg)

还有一个 SaaS（Software as a Service，软件即服务）的概念。与IaaS和PaaS相比，软件仅需透过互联网，而不须透过安装即可使用。SaaS本身是存储在提供商的云端或者服务器，用户使用时经由网页浏览器访问软件即服务。举个栗子，SaaS就像我们用电脑登录邮箱，只需打开邮箱网址，输入账号密码登录，即可使用邮箱。**对于小型企业来说，SaaS是采用先进技术的最好途径，它消除了企业购买、构建和维护基础设施和应用程序的需要。**

还有一个 CaaS（Container as a Service，容器即服务）

## 1.4 容器技术兴起
**容器技术无疑是过去十年间对软件开发行业影响最深远的技术之一**。
虽然容器技术早已出现，但 Docker 创新性地提出了“镜像”（image）的概念，实现了一种新型的应用打包、分发和运行机制，开发人员能够在几秒钟内完成应用程序的部署、运行，无需再担心环境不一致的问题。
从此，云计算从仅提供计算、存储、网络资源的初级阶段，发展成为具备强大软件交付和维护能力的综合性服务平台。

从虚拟机到容器，云计算市场经历了一次重大变革，甚至可以说是一次洗牌。在基于容器技术的容器编排市场中，Mesos、Swarm 和 Kubernetes 上演了一场史诗级“大战”。凭借先进的设计理念和高度开放的架构，Kubernetes 最终脱颖而出，成为容器编排领域的事实标准。
![](https://www.thebyte.com.cn/assets/cloud-history-3-DqfAAlWC.svg)
这期间有 2 个重要的里程碑：
- 2013 年，Docker 发布，容器逐步替代虚拟机（Virtual Machine，VM），云计算进入容器时代。**Docker 最大的创新在于容器镜像，它包含了一个应用运行所需的完整环境（整个操作系统的文件系统），具有一致性、轻量级、可移植、编程语言无关等特性，实现 “一次构建，随处运行”**。
- 2017 年底，Kubernetes 赢得“容器编排之战”（Container Orchestration Wars）的胜利，云计算进入 Kubernetes 时代。Kubernetes 是 Google 基于内部容器管理系统 Borg 开源的容器编排调度系统，让容器的应用从“小打小闹”进入大规模工业生产阶段。Kubernetes 将底层的计算、存储和网络资源抽象为标准化的 API 对象，应用不再依赖特定的基础设施，能够轻松在不同环境（如本地、云端、混合云）间迁移。

## 1.5 云计算形态演进总结
对以上云计算演进总结分析，可以发现以下规律：
- **工作负载的变化**：从早期的物理服务器，通过虚拟化技术演进为虚拟机，再通过容器化技术演进为目前的容器。
- **隔离单元**：无论是启动时间还是单元大小，物理机、虚拟机、容器一路走来，实现了从重量级到轻量级的转变。
- **供应商**：从闭源到开源，从 VMware 到 KVM，到 OpenStack，再到 Kubernetes。从单一供应商到跨越多个供应商，从公有云到自建云，再到混合云。

从物理机到虚拟机再到容器，应用的构建和部署变得越来越轻、越来越快。从 IaaS 诞生到 PaaS、FaaS 一路演进，底层基础设施和平台越来越强大，以不同形态对上层应用提供强力支撑。
对于 XaaS 的一路演进，可以简单归纳为：

- 有了 IaaS，客户不用关注物理机器，只需关注基础架构及应用程序。
- 有了 PaaS，客户不用关注基础架构，只需关注应用程序。
- 有了 FaaS，客户只需关注功能和数据。

# 2 云原生出现的背景
## 2.1 软件正在吞噬世界
2011 年 8 月 20 日华尔街日报上，Mark Andreessen 发表了名为“Why Software Is Eating the World”的文章，内容主要阐述了软件如何影响各个行业。
文中列出了被重塑的产业，具体有最大的书店 Amazon、最多人订阅的 Video service Netflix、最大的音乐公司 iTunes、Spotify 和 Pandora 等、成长最快的娱乐领域 videogame、最好的电影制片厂 Pixar、最大的行销平台 Google、Groupon、Facebook 等、成长最快的电信公司 Skype 、成长最快招聘公司 LinkedIn。
文章发表于 2011 年，2023 年再来回顾，互联网冲击已经无所不在，**部分软件已经变成水电煤一样的社会经济中的基础设施**，感触更加深刻。思考这样的软件如果宕机，对社会产生什么影响？

## 2.2 移动互联网在加剧变化
还是那篇文章，Mark Andreessen 展望互联网规模时，写道“在接下来的 10 年里，我预计全球至少有 50 亿人拥有智能手机，每个人每天都可以随时随地使用手机充分利用互联网”。
援引 Netflix 的一页 PPT，如 图Assumptions 所示，这里按照规模和变更速度将软件企业划分为四个象限/四种类型：
- 企业 IT（Enterprise IT）：规模小、变化慢，容易处理。
- 电信（Telcos）：规模大、变化慢，主要应对硬件失败。
- 初创公司（Startups）：规模小、变化快，主要应对软件失败。
- 互联网企业（Web-Scale）：规模大、变化快，软硬件或者说所有东西都会出问题。
![[Pasted image 20250412101128.png|图Assumptions]]

十年前乃至二十年前的**互联网时代，大多数软件企业都位于 图Assumptions 左边的两个象限：“规模或许有大有小，但是变更速度相对今天都不快”**。当企业发展壮大时，体现的也更多是在规模上，变更速度并不会发生质的变化。
而今天的**移动互联网时代，则都位于 图Assumptions 右边的两个象限：“无论规模是大是小，变更速度都要求非常快”**。当企业逐步发展壮大，规模十倍百倍增长时，对变更速度的要求并不会降低，甚至会要求更快。
这样的背景下，对软件质量有了更高的要求，软件开发的方式也不得不跟随时代而变化，首当其冲是：**如何解决规模越来越大，变更越来越快的难题**。

## 2.3 云原生的诞生
我们清晰地看到如此波澜壮阔的技术浪潮：
- 软件正在改变世界。
- 移动互联网让这个变革影响到每一个人。
- 传统软件开发方式受到巨大挑战。
- 云计算普及，软件上云成为趋势。
- 云的形态持续在演进。

过去二十年间，云的底层基础设施和平台越来越强大，软件架构的发展也逐渐和云匹配：
- 通过不可变基础设施（镜像）解决本地和远程一致性问题；
- 通过服务网格（ServiceMesh）将非业务逻辑从应用程序中剥离；
- 通过声明式 API 描述应用程序的状态，而不用管中间的处理过程；
- 通过 DevOps 理论以及配套的工具来提升研发/运维效率；
- 通过 ...。

应用程序中的非业务逻辑不断被剥离，并下沉到云/基础设施层，代码越来越轻量。由此，工程师的开发工作回归本质（**软件开发的本质是解决业务需求，各类“高深”、“复杂”的技术难题是业务需求的副产物，并不是软件开发的主题**）。

# 3 云原生的定义
云原生是一种构建和运行应用程序的方法，是一套技术体系和方法论。云原生（CloudNative）是一个组合词，Cloud+Native。Cloud表示应用程序位于云中，而不是传统的数据中心；Native表示应用程序从设计之初即考虑到云的环境，原生为云而设计，充分利用和发挥云平台的弹性+分布式优势。

Pivotal公司的Matt Stine于2013年首次提出云原生（CloudNative）的概念；2015年，云原生刚推广时，Matt Stine在《迁移到云原生架构》一书中定义了符合云原生架构的几个特征：12因素、微服务、自敏捷架构、基于API协作、扛脆弱性；到了2017年，Matt Stine在接受InfoQ采访时又改了口风，将云原生架构归纳为模块化、可观察、可部署、可测试、可替换、可处理6特质；而Pivotal最新官网对云原生概括为4个要点：DevOps+持续交付+微服务+容器。
2015年云原生计算基金会（CNCF）成立，CNCF掺和进来后，最初把云原生定义为包括：容器化封装+自动化容器编排+面向微服务；到了2018年，CNCF又更新了云原生的定义：不可变基础设施、容器、服务网格、微服务、声明式 API。

可见，不同的人和组织对云原生有不同的定义，相同的人和组织在不同时间点对云原生也有不同的定义，真是乱的一匹，搞得鄙人非常晕菜，我的应对很简单，选一个我最容易记住和理解的定义：**容器+微服务+DevOps+持续交付**。
符合云原生架构的应用程序应该是：采用开源堆栈（K8S+Docker）进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。

# 4 云原生代表技术
## 4.1 容器技术
[[容器]]

## 4.2 微服务
微服务的概念提出之后，由于理论不完善，加上技术不成熟，在一段时间内并没有被广泛关注。
直到 2014 年，经过 Martin Fowler（《MicroServices》作者）、Adrian Cockcroft（Netflix 架构师）、Neal ford（《卓有成效的程序员》作者）等人持续介绍、完善、演进和实践之后，微服务才算是一种真正丰满、独立的架构风格。

对于微服务的定义，援引 Netflix 云架构师 Adrian Cockcroft 的观点：微服务架构是一种面向服务的架构，由松耦合的具有有限上下文的元素组成。
Adrian Cockcroft 的观点中有两个核心概念：
1. 松耦合（Loosely Coupled）：意味着每个服务可以独立的更新，更新一个服务无需要求改变其他服务。
2. 限界上下文（Bounded Contexts）：意味着每个服务要有明确的边界性，你可以只关注自身软件的发布，而无需考虑谁在依赖你的发布版本。微服务和它的消费者严格通过 API 进行交互，不共享数据结构、数据库等。基于契约的微服务规范要求服务接口是稳定的，而且向下兼容。

### 4.2.1 微服务带来的技术挑战
微服务架构首先是一个分布式的架构，分布式意味着复杂性的挑战。
软件架构从巨石应用向微服务架构转型的过程中带来了一系列的非功能性需求，例如：
- 服务发现（Service Discovery）问题：解决“我想调用你，如何找到你”的问题。
- 服务调用问题
- 服务熔断（Circuit Breaker）问题：缓解服务之间依赖的不可靠问题。
- 负载均衡（Load Balancing）问题：通过均匀分配流量，让请求处理更加及时。
- 安全通讯问题：包括协议加密（TLS）、身份认证（证书/签名）、访问鉴权（RBAC）等。
- 伸缩扩容问题
- 服务监控告警问题
- 日志、配置中心、网关、请求链路追踪、分布式事务。。。

解决这些问题需要编写和维护⼤量非功能性代码，这些代码与业务代码逻辑混在一起，动不动还会遇到点匪夷所思的分布式 bug。所以说，**基础设施不完善的话，实施微服务很痛苦，服务越多越悲剧**。

### 4.2.2 后微服务时代
从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时代，此即为“后微服务时代”。
微服务架构中，有一些必须解决的问题，如负载均衡、伸缩扩容、传输通讯等等，这些问题可以说只要是分布式架构的系统就无法完全避免。先不考虑 Apache Dubbo、SpringCloud 或者别的解决方案，先换个思路想一下：“这些问题一定要由分布式系统自己来解决吗？”。
微服务时代，之所以选择在应用服务层面，而非基础设施层面去解决这些分布式问题，主要是**因为硬件构建的基础设施无法追赶上软件构成的应用服务的灵活性**。

直接来看 Kubernetes 在基础设施层面，解决分布式系统问题的方案：
- Kubernetes 用 CoreDNS 替代 Spring Cloud 服务发现组件 Eureka。
- Kubernetes 用 Service/Load Balancer 替代 Spring Cloud 中的负载均衡组件 Ribbon。
- Kubernetes 用 ConfigMap 替代 Spring Cloud 的配置中心 Config。
- Kubernetes 用 Ingress 代替 Spring Cloud 的网关组件 Zuul。
- ...

一旦虚拟化的硬件能够跟上软件的灵活性，那些与业务无关的技术性问题便有可能从软件层面剥离，并悄无声息地解决于硬件基础设施之内。此即为“后微服务时代”。

### 4.2.3 后微服务时代的二次进化
就功能的灵活性和强大性而言，Kubernetes 还比不上之前的 Spring Cloud 方案，原因在于某些问题位于应用系统与基础设施的交界处，而微观的服务管理（如单个请求的治理）并不能完全在基础设施层面得到解决。
假设微服务 A 调用了微服务 B 的两个服务，即 B1 和 B2。若 B1 正常运行，而 B2 持续出现 500 错误，那么在达到一定阈值后，就应对 B2 进行熔断，以避免引发雪崩效应。如果仅在基础设施层面处理这个问题，那就会陷入两难境地“切断 A 到 B 的网络通路会影响到 B1 的正常运作，不切断则会持续受到 B2 错误的影响”。
![[image-4.png]]
上述问题在使用 Spring Cloud 等方案中比较容易处理，既然是使用程序代码来解决问题，只要合乎逻辑，想要实现什么功能就实现什么功能。但对于 Kubernetes，由于基础设施粒度更粗糙，通常只能管理到容器层面，对单个远程服务的有效管理就相对困难。
类似的情况不仅仅在断路器上出现，服务的监控、认证、授权、安全、负载均衡等都有可能面临细化管理的需求。

为了解决这一类问题，微服务基础设施很快进行了第二次进化，引入了今天被称为“服务网格”（Service Mesh）的模式。

## 4.3 服务网格
服务网格（Service Mesh）的概念最早由 Buoyant 公司的创始人 William Morgan 于 2016 年提出。
2017 年 4 月，该公司发布了首个服务网格产品 Linkerd。同年，Morgan 的文章《[What’s a service mesh? And why do I need one?](https://www.thebyte.com.cn/architecture/ServiceMesh.html#footnote1)》在互联网中开始广泛流传，这篇文章内的解读被认定为服务网格的权威定义。
> [!note] 服务网格的定义
> 服务网格（ServiceMesh）是一个**基础设施层**，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证**请求在这些拓扑中可靠地穿梭**。在实际应用当中，服务网格通常是由一系列轻量级的**网络代理**组成的，它们与应用程序部署在一起，但**对应用程序透明**。

ServiceMesh 之所以称为“服务网格”，是因为每个节点同时运行着业务逻辑和具备通信治理能力的网络代理（如 Envoy、Linkerd-proxy）。这个代理被形象地称为“边车代理”（Sidecar），其中业务逻辑相当于主驾驶，处理辅助功能的代理软件相当于边车。
![[image-3.png]]

业内绝大部分服务网格产品通常由“数据平面”和“控制平面”两部分组成，以服务网格的代表实现 Istio 架构为例，如图 1-24 所示。
- **数据平面（Data plane）**：通常采用轻量级的网络代理（如 Envoy）作为 Sidecar，网络代理负责协调和控制服务之间的通信和流量处理，解决微服务之间服务熔断、负载均衡、安全通讯等问题。
- **控制平面（Control plane）**：包含多个控制组件，它们负责配置和管理 Sidecar ，并提供服务发现（Discovery）、配置管理（Configuration）、安全控制（Certificates）等功能。
![](https://www.thebyte.com.cn/assets/service-mesh-arc-Boo1iIx-.svg)

Sidecar 是一种常见的容器设计模式，Kubernetes 的工作负载 Pod 内可配置多个容器，业务容器之外的其他所有容器均可称为“边车容器”（Sidecar container）。如日志收集 Sidecar、请求代理 Sidecar 和链路追踪 Sidecar 等等。
服务网格本质是通过 iptables 劫持发送到应用容器的流量，将原本在业务层处理的分布式通信治理相关的技术问题，下沉到网络代理型边车中处理，实现业务与非业务逻辑解耦的目的。

## 4.4 DevOps
DevOps 核心本质是解决软件开发生命周期中的管理问题，我们先从一种名为“瀑布模型”的项目管理方法说起。

### 4.4.1 瀑布开发
1970 年，计算机科学家 Winston Royce 发表《Managing the development of large software systems》论文，首次描述了软件开发的分阶段流程，包括需求分析、设计、实现、测试和维护等阶段。

如下图所示，Royce 描述软件开发流程如瀑布流水一般，由一个阶段“流动”到下一个阶段，这种逐步递进的流程后来被称为“瀑布模型”（Waterfall Model）。
![|700x611](https://www.thebyte.com.cn/assets/waterfall-model-C2y9EkxO.svg)

但这种模式存在一些缺陷，瀑布模型产生于硬件领域，它是从制造业的角度去看软件开发的，产品迭代的频率经常按月为单位进行，在需求变化不多的年代，瀑布模型拥有其价值。随着软件行业的快速爆发，针对市场的快速变化和响应成了新的目标。这种场景下，需求无法得到快速验证是最大的风险，有可能花费数月开发的产品早已不符合市场需求。

### 4.4.2 敏捷开发
2001 年，Martin Fowler，Jim Highsmith 等 17 位著名的软件开发专家齐聚在美国犹他州雪鸟滑雪圣地，举行了一次敏捷方法发起者和实践者的聚会。这次会议中，他们正式提出了 Agile Software Development（敏捷开发）这个概念，还有模有样地签署了《敏捷宣言》:
![[image-5.png]]

迭代是敏捷开发理论的核心。坦白地说，迭代开发并不是新鲜的概念，但敏捷研发方法大大完善了迭代开发的理论，使之能够被广大的软件开发团队认可。具体的敏捷研发方法有极限编程、精益软件开发、Scrum 等。
虽然敏捷开发提升了开发效率，但它的范围仅限于开发和测试环节，并没有覆盖到部署环节。显然，运维部门并没有收益。相反的，甚至可以说“敏捷”加重了运维的负担。运维追求的目标是稳定，频繁变更是破坏稳定的根源。

那么，如何要化解开发与运维的矛盾呢？现在，到了 DevOps 上场的时间。

### 4.4.3 DevOps
DevOps 运动始于 2007 年左右，当时技术社区对开发/运维分工协作的方式、以及由此引发的冲突感到担忧。随着越来越多问题的出现，大家逐渐认识到：为了保证产品研发的效率、软件交付的质量，开发和运维必须紧密配合。
2009 年，比利时根特市举办了首届 DevOpsDays 大会，这届会议出乎意料的成功，引起人们广泛的讨论。DevOps 理论就此诞生！

> [!note] DevOps 的定义
> DevOps（Development 和 Operations 的合成词）是一种重视“软件开发人员（Dev）”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。
> 通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。

DevOps 的成功实践离不开工具上的支持，这其中包括最重要的**自动化 CI/CD 流水线**，通过自动化的方式打通软件从构建、测试到部署发布的整个流程。还有实时监控、事件管理、配置管理、协作平台等一系列工具/系统的配合。
![[image-6.png]]

## 4.5 不可变基础设施
### 4.5.1 可变的基础设施
从管理基础设施的层面看：“可变”的基础设施与传统运维操作相关。例如，有一台服务器部署的是 Apache，现在想换成 Nginx。传统手段是先卸载掉 Apache，重新安装一个 Nginx，再重启系统让这次变更生效。
上述的过程中，装有 Apache 的 Linux 操作系统为了满足业务需求，进行了一次或多次变更，该 Linux 操作系统就是一个可变的基础设施。可变的基础设施会导致以下问题：
- **重大故障时，难以快速重新构建服务**：持续过多的手动操作并且缺乏记录，会导致很难由标准初始化的服务器来重新构建起等效的服务；
- **不一致风险**：类似于程序变量因并发修改而带来的状态不一致风险。服务运行过程中，频繁的修改基础设施配置，同样会引入中间状态，导致出现无法预知的问题。

### 4.5.2 不可变基础设施
2013 年 6 月，Chad Fowler 撰写了一篇名为 《[Trash Your Servers and Burn Your Code: Immutable Infrastructure and Disposable Components](https://www.thebyte.com.cn/architecture/Immutable.html#footnote1)》的文章，提出了 Immutable Infrastructure（不可变基础设施）的概念。这一前瞻性的构想，伴随着 Docker 容器技术的兴起、微服务架构的流行，得到了事实上的检验。
不可变基础设施思想的核心是，**任何基础设施的运行实例一旦创建之后就变成只读状态**。如需修改或升级，应该先修改基础设施的配置模版（例如 yaml、Dockerfile 配置），之后再使用新的运行实例替换。例如上面提到的 Nginx 升级案例，应该准备一个新的装有 Nginx 的 Linux 操作系统，而不是在 Linux 操作系统上原地更新。

从容器的角度看，**镜像就是一个不可变基础设施**。工程师交付的产物从有着各种依赖条件的安装包变成一个不依赖任何环境的镜像文件，当软件需要升级或者修改配置时，我们修改镜像文件，新起一个容器实例替换，而不是在运行容器内修改。有了镜像之后，本地与测试环境不一致、测试环境与正式环境不一致问题消失殆尽了。
相比可变基础设施，不可变基础设施通过标准化描述文件（如 yaml、dockerfile 等）统一定义，同样的配置拉起的服务，绝对不可能出现不一致的情况。从此，我们可以快速拉起成千上万一模一样的服务，服务的版本升级、回滚也成为常态。

## 4.6 声明式设计
声明式设计是指一种软件设计理念：“我们描述一个事物的目标状态，而非达成目标状态的流程”。至于目标状态如何达成，则由相应的工具在其内部实现。

和声明式设计相对的是命令式设计（又叫过程式设计），两者的区别是：
1. 命令式设计：命令“机器”如何去做事情（how），这样不管你想要的是什么（what），它都会按照你的命令实现；
2. 声明式设计：告诉“机器”你想要的是什么（what），让机器想出如何去做（how）。

看以声明式设计为核心的 Kubernetes。
下面的 YAML 文件中定义了一个名为 nginx-deployment 的 Deployment 资源。其中 spec 部分**声明**了部署后的具体状态（以 3 个副本的形式运行）。
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```
通过编写 YAML 文件表达我们的需求和意图，资源如何创建、服务如何关联，至于具体怎么实现，我们完全不需要关心，全部甩手给 Kubernetes。

# 5 云原生架构技术栈总结
如果你有志投入云原生领域，希望构建一个高可用（高研发效率、低资源成本，且兼具稳定可靠）的云原生架构，对能力要求已提升到史无前例的程度。总结来说，除了掌握基础的 Docker 和 Kubernetes 知识外，熟知下图所示的几个领域也是必备要求。
![](https://www.thebyte.com.cn/assets/cloud-C6z_sZLk.svg)

1. 容器运行时：Docker、Containerd、CRI-O、Kata Containers。
2. 镜像和仓库：Harbor、Dragonfly、Nydus。
3. 应用封装：Kustomize、Helm、Operator、OAM。
4. 持续集成：Gitlab、Tekton。
5. 持续部署：ArgoCD、FluxCD。
6. 容器编排：Kubernetes。
7. 服务网格: Istio、Envoy、Linkerd。
8. 网关：Ingress-Nginx、Kong、Traefik。
9. 日志：Grafana Loki、Elastic Stack、ClickHouse。
10. 监控/观测：Prometheus、Grafana、OpenTelemetry。
11. 机器学习/离在线业务混合部署：Volcano、Koordinator...。

---
# 6 引用
云原生的定义：https://blog.csdn.net/pushiqiang/article/details/119492602
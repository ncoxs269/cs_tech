2025-04-16 22:00
Status: #idea
Tags: [[Go底层原理]]

# 1 面试题目
先带着以下几个关于GMP模型的面试题目进行思考，以加深理解和掌握：
1. 什么是GMP模型？请解释其基本概念？回答要点：解释G、M、P的概念及其在调度模型中的角色。
2. 如何理解GMP模型中线程的内核态和用户态？回答要点：区分内核态线程和用户态线程，并说明它们在GMP模型中的作用。
3. Go语言中的Goroutine与线程的映射关系是怎样的？为什么选择这种映射方式？回答要点：解释Goroutine与线程的多对多映射关系及其优点。
4. GMP模型如何解决线程调度中的锁竞争问题？回答要点：介绍全局队列和本地队列的使用，以及G的分配机制。
5. GMP模型中的Stealing机制是什么？它如何工作？回答要点：描述Stealing机制的原理及其在Goroutine调度中的应用。
6. 什么是Hand off机制？在什么情况下会使用该机制？回答要点：解释Hand off机制及其在阻塞和系统调用中的应用。
7. 如何理解GMP模型中的抢占式调度？它解决了哪些问题？回答要点：说明抢占式调度的原理及其在防止协程饿死中的作用。
8. 什么是G0和M0？它们在GMP模型中扮演什么角色？回答要点：描述G0和M0的定义及其在Goroutine调度中的功能。
9. 请详细说明GMP模型中的调度策略。回答要点：逐步解释Goroutine的创建、唤醒、偷取、切换、自旋、系统调用和阻塞处理策略。
10. 如何在实际项目中调优GMP调度模型？回答要点：讨论如何通过调整GOMAXPROCS等参数来优化调度性能。

# 2 什么是GMP
## 2.1 基本概念
Go语言中的并发是多对多的线程模型，Go为了实现该模型自己实现了一个运行时调度器来负责Go中的用户线程与内核线程的动态关联。此模型有时也被称为 **混合型线程模型**，**即用户调度器实现用户线程到内核线程的“调度”，内核调度器实现系统线程到CPU上的调度**。

内核线程就是直接由操作系统内核管理的线程。用户线程就是由用户程序管理的线程，需绑定到内核线程上执行。

多对多模型，相对于一对一模型，减少了内核线程切换的上下文开销；相对于多对一模型，实现了真正的并行，并且避免了线程阻塞导致程序无法运行的问题。

## 2.2 组成结构
GPM的组成结构：
- M是Machine，操作系统管理的内核线程，goroutine就是跑在M之上的。
	在linux平台上是用clone系统调用创建的，其与用linux pthread库创建出来的线程本质上是一样的，都是利用系统调用创建出来的OS线程实体。
	M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。
- G是goroutine，它是go语言的协程，比线程更加轻量级，初始化时仅占用几KB的栈内存，并且栈内存可以根据需要动态伸缩。
	包含了栈、指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。
- P是Processor，主要作用是管理G对象，并为G在M上的运行提供本地化资源。
	- P的数量决定了可以并行执行的Goroutine的数量。Processor的数量是在启动时被设置为**环境变量GOMAXPROCS**的值，或者通过运行时调用函数GOMAXPROCS()进行设置，数量固定。通常等于系统cpu核心数。

G队列：
- 全局G队列：存放等待运行的G。
- P的本地G队列：又叫runqueue，运行队列。存放不超过256个G。当新建协程时优先将G存放到本地队列，本地队列满了后将一半的G移动到全局队列。

特殊的G0和M0：
- **G0**：每个M启动时创建的第一个Goroutine，仅用于调度，不执行用户代码。每个M都有一个G0。
- **M0**：程序启动后的第一个主线程，负责初始化操作和启动第一个Goroutine。

# 3 为什么要有P？
从两级线程模型来看，似乎并不需要P的参与，有G和M就可以了，那为什么要加入P这个东东呢？

## 3.1 被废弃的调度器
其实Go语言运行时系统早期(Go1.0)的实现中并没有P的概念，Go中的调度器直接将G分配到合适的M上运行。但这样带来了很多问题：
- **锁竞争**：每个M（线程）想要执行、放回G（协程）都必须访问一个全局G队列，因此对G的访问需要加锁以保证并发安全。当有很多线程时，锁竞争激烈，影响系统性能。
- **局部性破坏**：M转移G会造成延迟和额外的系统负载。例如，当一个G内创建另一个G'时，为了继续执行G，需要将G'交给另一个M'执行，这会破坏程序的局部性。
- **goroutine传递问题**：M经常在M之间传递goroutine，这导致调度延迟增大及额外的性能损耗

## 3.2 P的引入
为了解决类似的问题，后面的Go（Go1.1）运行时系统加入了P，让P去管理G对象，M要想运行G必须先与一个P绑定，然后才能运行该P管理的G。
这样带来的好处是：
- 大大避免了全局队列的锁竞争
- 程序拥有更好的局部性
- 我们可以在P对象中预先申请一些系统资源（本地资源），G需要的时候先向自己的本地P申请（无需锁保护），如果不够用或没有再向全局申请，而且从全局拿的时候会多拿一部分，以供后面高效的使用。

# 4 调度策略
## 4.1 创建
通过`go func()`创建一个协程。新创建的协程优先保存在P的本地G队列。如果本地队列满了，会将P本地队列中的一半G移入全局队列。

## 4.2 切换
G1运行完后，M上运行的Goroutine切换回G0，G0负责调度协程的切换。G0从P的本地队列获取G2，实现M的复用。

## 4.3 偷取
如果M在自己P队列找到G就拿出来开始运行，否则去全局队列看看。由于全局队列需要锁保护，如果里面有很多任务，会转移一批到本地P队列中，避免每次都去竞争锁。如果全局队列还是没有，就要开始玩狠的了，直接从其他P队列偷任务了（偷一半任务回来）。

## 4.4 自旋
处于运行状态但是没有可执行goroutine的M，就叫自旋的M。它会尝试从全局队列、其他M的本地队列中获取任务。
如果我们在一个Goroutine中通过 go 关键字创建了大量G，这些G虽然暂时会被放在同一个队列，但是它们总会被M找到并执行。

## 4.5 系统调用(hands off)
当G进行系统调用时，M会进入内核态，被内核调度器调度出CPU并处于阻塞状态，与该M关联的其他G就没有办法继续执行了。
但Go运行时系统的一个**监控线程(sysmon线程)**能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G。这就是为何大量I/O操作会导致大量线程被创建的原因。
如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行。M会释放绑定的P，把P转移给其他空闲的M执行。
当系统调用结束，M会尝试获取一个空闲的P。

## 4.6 阻塞处理
当G因channel阻塞时，该G会脱离当前的M与P，而不会阻塞M。超过10ms时，M会寻找其他可运行的G。

## 4.7 抢占式机制
Go的运行时调度器中也有类似的抢占机制，但并不能保证抢占能成功，因为Go运行时系统并没有内核调度器的中断能力，它只能通过向运行时间过长的G中设置抢占flag的方法温柔的让运行的G自己主动让出M的执行权。
Go抢占式调度的机制就是利用在判断要不要扩栈（例如调用函数）的时候顺便查看以下自己的抢占flag，决定是否继续执行，还是让出自己。运行时系统的监控线程会计时（10ms）并设置抢占flag到运行时间过长的G，然后G在有函数调用的时候会检查该抢占flag，如果已设置就将自己放入全局队列，这样该M上关联的其他G就有机会执行了。
但如果正在执行的G是个很耗时的操作且没有任何函数调用(如只是for循环中的计算操作)，即使抢占flag已经被设置，该G还是将一直霸占着当前M直到执行完自己的任务。

# 5 状态机
接下来看一下程序中GMP的分布：
![[image-15.png]]
有不在运行队列中的G：如正处于channel的阻塞状态的G，还有脱离P绑定在M的(系统调用)G，还有执行结束后进入P的gFree列表中的G等等。

## 5.1 G状态
G的主要几种状态：（基于Go1.13，具体代码见\<GOROOT\>/src/runtime/runtime2.go）：
- \_Gidle：刚刚被分配并且还没有被初始化，值为0，为创建goroutine后的默认值
- \_Grunnable： 没有执行代码，没有栈的所有权，存储在运行队列中，可能在某个P的本地队列或全局队列中。
- \_Grunning： 正在执行代码的goroutine，拥有栈的所有权。
- \_Gsyscall：正在执行系统调用，拥有栈的所有权，与P脱离，但是与某个M绑定，会在调用结束后被分配到运行队列。
- \_Gwaiting：被阻塞的goroutine，阻塞在某个channel的发送或者接收队列。
	- 当goroutine读写channel发生阻塞时候，会调用gopark函数，该G会脱离当前的M与P，调度器会执行schedule函数调度新的G到当前M。
- \_Gdead： 当前goroutine未被使用，没有执行代码，可能有分配的栈，分布在空闲列表gFree。可能是一个刚刚初始化的goroutine，也可能是执行了goexit退出的goroutine。
- \_Gcopystac：栈正在被拷贝，没有执行代码，不在运行队列上，执行权在
- \_Gscan ： GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在

## 5.2 P状态
- \_Pidle ：P没有运行用户代码，被空闲队列或者改变其状态的结构持有，运行队列为空
- \_Prunning ：被 M 持有，并且正在执行用户代码
- \_Psyscall：没有执行用户代码，当前 M 陷入系统调用
- \_Pgcstop ：被 M 持有，P由于垃圾回收被停止
- \_Pdead ：P已经不被使用

---
# 6 引用
[GMP原理](https://segmentfault.com/a/1190000045115346#item-5-11)
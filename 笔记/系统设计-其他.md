2025-12-06 15:41
Status: #idea
Tags:


# 2 设计题
## 2.1 库存管理设计
### 2.1.1 redis库存
#### 2.1.1.1 lua脚本实现原子性
常用方案redis+lua，借助redis单线程执行+lua脚本中的逻辑，可在一次执行中顺序完成的特性达到原子性（叫排它性更准确，因为不具备回滚动作，异常情况需自己手动编码回滚）：
```lua
-- 1. 获取库存缓存key KYES[1] = hot_{itemCode-skuCode}_stock
local hot_item_stock = KYES[1]

-- 2. 获取剩余库存数量
local stock = tonumber(redis.call('get', hot_item_stock))

-- 3. 购买数量
local buy_qty = tonumber(ARGV[1])

-- 4. 如果库存小于购买数量，则返回1，表达库存不足
if stock < buy_qty then
  return 1
end

-- 5. 库存足够，更新库存数量
stock = stock - buy_qty
redis.call('set', hot_item_stock, tostring(stock))

-- 6. 扣减成功则返回2，表达库存扣减成功
return 2
```

#### 2.1.1.2 幂等性和可追溯性
但脚本还有一些问题：
- 不具备幂等性，同个订单多次执行会导致重复扣减，手动回滚也无法判断是否会回滚过，会出现重复增加的问题    
- 不具备可追溯性，不知道库存被谁被哪个订单扣减了

增强后的lua脚本：
```lua
-- 1. 获取库存扣减记录缓存 key KYES[2] = hot_{itemCode-skuCode}_deduction_history
local  hot_deduction_history = KYES[2]

-- 2. 使用 Redis Cluster hash tag 保证 stock 和 history 在同一个槽
local exist = redis.call('hexists', hot_deduction_history, ARGV[2])
-- 3. 请求幂等判断,存在返回0,表达已扣减过库存
if exist == 1 then return 0 end

-- 4. 获取库存缓存key KYES[1] = hot_{itemCode-skuCode}_stock
local hot_item_stock = KYES[1]

-- 5. 获取剩余库存数量
local stock = tonumber(redis.call('get', hot_item_stock))

-- 6. 购买数量
local buy_qty = tonumber(ARGV[1])

-- 7. 如果库存小于购买数量 则返回1,表达库存不足
if stock < buy_qty then return 1 end

-- 8. 库存足够
-- 9. 1.更新库存数量
-- 10. 2.插入扣减记录 ARGV[2] = ${扣减请求唯一key} - ${扣减类型} 值为 buy_qty
stock = stock - buy_qty
redis.call('set', hot_item_stock, tostring(stock))
redis.call('hset', hot_deduction_history, ARGV[2], buy_qty)

-- 11. 如果剩余库存等于0则返回2,表达库存已为0
if stock == 0 then return 2 end

-- 12. 剩余库存不为0返回 3 表达还有剩余库存
return 3 end
```
利用Redis Cluster hash tag保证stock和history在同个槽，这样lua脚本才能正常执行。

回滚逻辑先判断hot_deduction_history里有没有 ${扣减请求唯一key}：
- 有，则执行回补逻辑，并删除唯一key
- 没有，则认定回补成功

#### 2.1.1.3 防悬挂
但这个回滚逻辑仍然有问题，不能防悬挂（订单取消的回滚请求先到，扣减请求后到）。
所以可以设计两个 deduction_history，一个保存正常请求，一个保存回滚请求（正常请求和回滚请求的key是一样的）。

正常请求：
- 如果 key 不在两个 history 中，则执行
- 如果 key 在两个 history 中任意一个，则不执行

回滚请求：
- 如果 key 在正常 history 中，且不在回滚 history 中，则执行
- 如果 key 不在两个 history 中，则把 key 写入回滚 history，不执行回滚

#### 2.1.1.4 高可用
运用Redis部署的高可用方案：
- 采用Redis Cluster（数据分片+ 多副本 + 同步多写 + 主从自动选举）
- 多写节点分（同城异地）多中心防止意外灾害

定期归档冷数据。定期 + 库存为0触发redis数据往DB同步。

部分头部电商采用弱缓存抗读（非库存不足，不实时更新），DB抗写的方案。该方案前提在于，通过一系列技术方案，流量落到库存已相对低且平滑了（扛得住，不用再自己实现操作原子性）。

## 2.2 抢红包系统设计
### 2.2.1 背景
和秒杀类型，抢红包也是读多写少。
抢红包有 3 个核心流程：**红包金额拆分->抢红包->打款**。

包红包、发红包、抢红包、拆红包
红包过期退款
难点分析：
- 不能超发
- 支持高并发：1亿用户抢红包
- 红包金额什么时候算、怎么算
- 打款

### 2.2.2 红包表结构
红包主表：
```sql
CREATE TABLE `t_redpack_activity`
(
    `id`         bigint(20)     NOT NULL COMMENT '主键',
    `total_amount`     decimal(10, 2) NOT NULL DEFAULT '0.00' COMMENT '总金额',
    `surplus_amount`     decimal(10, 2) NOT NULL DEFAULT '0.00' COMMENT '剩余金额',
    `total` bigint(20)     NOT NULL DEFAULT '0' COMMENT '红包总数',
    `surplus_total` bigint(20)     NOT NULL DEFAULT '0' COMMENT '红包剩余总数',
    `user_id`    bigint(20)     NOT NULL DEFAULT '0' COMMENT '用户编号',
    `version` bigint(20)     NOT NULL DEFAULT '0' COMMENT '版本号',
    PRIMARY KEY (`id`)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8;
```

子红包表：
```sql
CREATE TABLE `t_redpack`
(
    `id`         bigint(20)     NOT NULL COMMENT '主键',
    `activity_id`         bigint(20)     NOT NULL DEFAULT 0 COMMENT '红包活动ID',
    `amount`     decimal(10, 2) NOT NULL DEFAULT '0.00' COMMENT '金额',
    `status`     TINYINT(4) NOT NULL DEFAULT 0 COMMENT '红包状态 1可用 2不可用',
    `version` bigint(20)     NOT NULL DEFAULT '0' COMMENT '版本号',
    PRIMARY KEY (`id`)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8;
```

抢红包明细表：
```sql
CREATE TABLE `t_redpack_detail`
(
    `id`         bigint(20)     NOT NULL COMMENT '主键',
    `amount`     decimal(10, 2) NOT NULL DEFAULT '0.00' COMMENT '金额',
    `user_id`    bigint(20)     NOT NULL DEFAULT '0' COMMENT '用户编号',
    `redpack_id` bigint(20)     NOT NULL DEFAULT '0' COMMENT '红包编号',
    `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8;
```

因为有了抢红包明细表，所以用户查询红包记录就可以用这个表。
而红包表就可以跳过分库分表拆分。

### 2.2.3 数据库方案
#### 2.2.3.1 发红包流程
![[image-137.png]]

#### 2.2.3.2 抢红包流程
![[image-138.png]]

### 2.2.4 缓存方案
#### 2.2.4.1 发红包流程
![[image-139.png]]

#### 2.2.4.2 抢红包流程
![[image-140.png]]

### 2.2.5 SET化方案
![[image-143.png]]

![[image-144.png]]
![[image-145.png]]

### 2.2.6 拆分方案
#### 2.2.6.1 实时拆分
实时拆分，指的是在**抢红包时实时计算**每个红包的金额，以实现红包的拆分过程，对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从正态分布规律。

![[image-148.png]]

#### 2.2.6.2 预先生成
预先生成，指的是在红包**开抢之前**已经完成了红包的**金额拆分**，抢红包时只是依次取出拆分好的红包金额，对拆分算法要求较低，可以拆分出随机性很好的红包金额，通常需要结合队列使用。

通常使用 **二倍均值法** 的算法拆分红包金额。拆分算法可以描述为：假设剩余拆分金额为 M，剩余待拆分红包个数为 N，红包最小金额为 1 元，那么定义当前红包的金额为：
```go
m=rand(1,floor(M/N∗2))
```
因为 N >= 2，所以 M/N\*2 <= M，表示一定能保证后续红包能拆分到金额。

![[image-146.png]]

![[image-147.png]]

### 2.2.7 限流
和秒杀系统一样。不过抢红包一般是内部系统，不需要针对性限流。

![[image-141.png]]

### 2.2.8 数据库分库分表优化
![[image-142.png]]

### 2.2.9 打款
打款可以用消息队列异步实现。

### 2.2.10 抢红包
#### 2.2.10.1 mysql抢红包
当多个 client 抢红包时，获取该活动下所有可用的红包明细，随机返回其中一条然后再去更新，更新成功则代表用户抢到了该红包，失败则代表出现了冲突，可以循环进行重试。
因为红包明细有多个，这样冲突也降低了。

#### 2.2.10.2 Redis队列方案
选用队列串行化的方案，抢红包整个过程只会操作 Redis，且都是简单高效的 Pop 和 Push 命令操作。
抢红包流程：先从红包队列中 **Pop** **占有红包**，然后 Push 红包到消息队列（待异步打款处理），并同步告知用户抢到红包的结果，抢红包流程就结束了。

当然，在实际应用中，占有红包过程中还会有一些前置规则校验，比如用户是否已经领取过，领取次数是否已经达到上限等？红包占有流程图如下：
![[image-136.png]]
使用lua脚本保证抢红包的原子性。

---

---
# 1 引用
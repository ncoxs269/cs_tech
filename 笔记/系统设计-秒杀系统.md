2025-10-28 16:04
Status: #idea
Tags: [[场景题和设计题]]

# 1 背景
秒杀一般出现在商城的促销活动中，指定了一定数量（比如：10个）的商品（比如：手机），以极低的价格（比如：0.1元），让大量用户参与活动，但只有极少数用户能够购买成功。

一般在秒杀时间点（比如：12点）前几分钟，用户并发量才真正突增，达到秒杀时间点时，并发量会达到顶峰。这个峰值持续的时间其实是非常短的，这样就会出现**瞬时高并发**的情况。

由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。这是非常典型的**读多写少**的场景。

秒杀流程：
![[image-134.png]]

# 2 概括
设计：
- redis预热库存
- redis预减库存
- MQ异步下单和最终扣减数据库库存

挑战&问题：
- 高并发
- 加了缓存之后的三大问题：击穿、穿透、雪崩
- 如何解决热点数据问题？单个商品过热，请求量可能redis都承受不住
- 防止用户重复秒杀
	- 前端限制：一次点击之后按钮置灰几秒钟
	- 后端限制：在redis中记录哪些用户已经秒杀过了
- 秒杀中如何处理超卖问题？
	- MySQL中的排他锁 `update` `table_prmo` `set` `num = num - 1` `WHERE` `id = 1001` `and` `num > 0`
	- redis单线程特性处理秒杀超卖
- 秒杀中如何解决重复下单问题？
	- 消费幂等性
- 库存扣减成功，下单失败（MQ消息失败）怎么办？
	- 回退库存
	- 分布式事务：将减库存与生成订单操作组合为一个事务
- 订单超时后如何取消
- 限流削峰措施
	- 验证码，分散同一时间下单的用户数量
	- 漏桶和令牌桶
	- 封用户ID、IP

# 3 页面静态化和CDN加速
活动页面是用户流量的第一入口，所以是并发量最大的地方。如果这些流量都能直接访问服务端，恐怕服务端会因为承受不住这么大的压力，而直接挂掉。
活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做**静态化处理**。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。

但只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，网速各不相同。这就需要使用CDN，让用户最快访问到活动页面。

# 4 缓存预热和缓存穿透
如果有数十万的请求过来，同时通过数据库查库存是否足够，此时数据库可能会挂掉。所以应该改用缓存，比如：redis。
在项目启动之前，先把缓存进行**预热**。即事先把所有的商品，同步到缓存中，这样商品基本都能直接从缓存中获取到。

如果查询的商品不存在，同一时刻有大量的请求同时去查缓存中没有数据，然后又同时访问数据库（缓存穿透），结果数据库可能扛不住压力。这就需要加锁，最好使用分布式锁。
![[image-131.png]]

但很显然这些请求的处理性能并不好，有没有更好的解决方案？可以把不存在的商品id也缓存起来。
![[image-132.png]]
下次，再有该商品id的请求过来，则也能从缓存中查到数据，只不过该数据比较特殊，表示商品不存在。需要特别注意的是，这种特殊缓存设置的超时时间应该尽量短一点。

# 5 秒杀扣减库存
## 5.1 预扣库存
真正的秒杀商品的场景，不是说扣完库存，就完事了，如果用户在一段时间内，还没完成支付，扣减的库存是要加回去的。
所以，在这里引出了一个**预扣库存**的概念，下单时预扣库存，付款时释放库存(数据库)。
预扣库存的主要流程如下：
![[image-133.png]]
## 5.2 数据库扣减
使用数据库扣减库存，是最简单的实现方案了，假设扣减库存的sql如下：
```sql
update product set stock=stock-1 where id=123;
```

但如何控制库存不足的情况下，不让用户操作呢？这就需要在update之前，先查一下库存是否足够了：
```sql
int stock = mapper.getStockById(123);
if(stock > 0) {
  int count = mapper.updateStock(123);
  if(count > 0) {
    addOrder(123);
  }
}
```
查询操作和更新操作不是原子性的，会导致在并发的场景下，出现**库存超卖**的情况。加锁的话性能就不好。

还有更优雅的处理方案，即**基于数据库的乐观锁**：
```sql
update product set stock=stock-1 where id=product and stock > 0;
```

但需要频繁访问数据库，在高并发的场景下，可能会造成系统雪崩。而且容易出现多个请求同时竞争行锁的情况，造成相互等待从而出现死锁的问题。
## 5.3 redis扣减库存
使用lua脚本扣减库存：
1. 先判断商品id是否存在，如果不存在则直接返回。
2. 如果库存>0，则扣减库存。
3. 如果库存=0，是直接返回，表示库存不足。

# 6 MQ处理下单和支付
三个核心流程中，真正并发量大的是秒杀功能，下单和支付功能实际并发量很小。所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成mq异步处理的。而支付功能，比如支付宝支付，是业务场景本身保证的异步。
![[image-135.png]]
要注意以下消息问题：
- 消息丢失：生产端使用消息发送表和定时任务来解决
- 重复消费：消费端使用消息处理表保证幂等消费

# 7 订单取消问题
如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。
- 一个实现方法是定时任务轮询。
- 另一个方法是使用延迟队列。下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。
	- 达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。
	- 如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。

# 8 限流
有些高手，并不会像我们一样老老实实，通过秒杀页面点击秒杀按钮，抢购商品。他们可能在自己的服务器上，模拟正常用户登录系统，跳过秒杀页面，直接调用秒杀接口。
## 8.1 接口限流
常用的后端限流方法有 **漏桶算法** 和 **令牌桶算法**。
## 8.2 针对性限流
可以对同一用户ID限流。但有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这时需要加同一ip限流功能。
但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。

别以为限制了用户和ip就万事大吉，有些高手甚至可以使用代理，每次都请求都换一个ip。这时可以限制请求的接口总次数。

还可以加验证码，可能更精准一些，同样能限制用户的访问频次，但好处是不会存在误杀的情况。

不过这样有些影响用户体验，我们可以通过提高业务门槛，比如只有会员才能参与秒杀活动，普通注册用户没有权限。或者，只有等级到达3级以上的普通用户，才有资格参加该活动。

---
# 9 引用
2025-04-12 15:24
Status: #idea
Tags: [[分布式]]

# 1 分布式ID
## 1.1 什么是分布式ID
`全局唯一ID`就叫`分布式ID`。

拿MySQL数据库举个栗子：在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。
但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有`唯一ID`做标识。此时一个能够生成`全局唯一ID`的系统是非常必要的。

## 1.2 分布式ID的要求
1. **唯一性**：全局唯一，无重复（最核心要求）；
2. **高可用**：生成服务不能单点故障，需支持扩容；
3. **高性能**：生成响应快（毫秒级甚至微秒级），支撑高并发场景；
4. **有序性**：部分场景需支持递增（如订单 ID 需按时间排序，便于查询 / 统计），或者不严格递增、趋势递增；
5. **安全性**：避免泄露业务敏感信息（如用户 ID 不能连续，防止遍历；避免暴露机器 / 时间等隐私）；
6. **兼容性**：支持跨数据库、跨语言，格式易存储（如数字型 ID 比字符串型更节省存储）。

## 1.3 分布式ID方案
### 1.3.1 几种不太推荐的方案
#### 1.3.1.1 基于UUID
UUID并不适用于实际的业务需求。像用作订单号`UUID`这样的字符串没有丝毫的意义，看不出和订单相关的有用信息。
而对于数据库来说用作业务`主键ID`，它不仅是太长还是无序的字符串，存储性能差查询也很耗时，所以不推荐用作`分布式ID`。

适用场景
- 无需有序性的场景：如日志 ID、缓存 key、临时文件名称；
- 对 ID 可读性、存储开销无要求的场景；
- 快速开发、无需额外依赖的场景（如原型开发、内部工具）。

拓展优化：
- 优化方案：UUID 压缩（如将 128 位字符串转为 64 位整数或 32 位字符串，减少存储开销）；
- 场景适配：日志 ID 用 UUID4（无安全风险），用户唯一标识用 UUID5（基于手机号哈希，避免重复）；

#### 1.3.1.2 基于数据库自增ID
基于数据库的`auto_increment`自增ID完全可以充当`分布式ID`，具体实现：需要一个单独的MySQL实例用来生成ID。
当我们需要一个ID的时候，向表中插入一条记录返回`主键ID`，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！

#### 1.3.1.3 基于数据库集群模式
害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。
那这样还会有个问题，两个MySQL实例的自增ID都从1开始，会生成重复的ID怎么办？**解决方案**：设置`起始值`和`自增步长`。
例如一个起始值=1，步长=2；另一个起始值=2，步长等于2。

那如果集群后的性能还是扛不住高并发咋办？就要进行MySQL扩容增加节点，这是一个比较麻烦的事。
增加第三台`MySQL`实例需要人工修改一、二两台`MySQL实例`的起始值和步长，把`第三台机器的ID`起始生成位置设定在比现有`最大自增ID`的位置远一些，但必须在一、二两台`MySQL实例`ID还没有增长到`第三台MySQL实例`的`起始ID`值的时候，否则`自增ID`就要出现重复了，**必要时可能还需要停机修改**。

### 1.3.2 基于数据库的号段模式
号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号加载到内存。表结构如下：
```sql
CREATE TABLE id_generator (
  id int(10) NOT NULL,
  max_id bigint(20) NOT NULL COMMENT '当前最大id',
  step int(20) NOT NULL COMMENT '号段的布长',
  biz_type    int(20) NOT NULL COMMENT '业务类型',
  version int(20) NOT NULL COMMENT '版本号',
  PRIMARY KEY (`id`)
)
```
version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性。

流程：
1. 搭建 ID 生成服务（独立微服务），后端依赖数据库存储号段信息（如表结构；
2. ID 生成服务启动时，从数据库申请一个号段（如订单业务申请 1000-2000），更新`max_id=2000`；
3. 服务内存中维护该号段，后续生成 ID 时直接从内存中递增，无需每次访问数据库；
4. 当号段使用到阈值（如 80%）时，异步申请下一个号段，避免号段耗尽导致阻塞。

优点
- 高性能：内存中生成 ID，TPS 可达十万级，支撑高并发；
- 高可用：号段预分配，数据库短暂宕机不影响 ID 生成；支持多实例部署（不同实例申请不同号段）；
- 有序性：同一号段内 ID 递增，全局趋势递增（满足大部分排序需求）；
- 可扩展：按业务类型分号段（如订单、用户、商品），互不干扰；步长可动态调整。

缺点：
- 需要单独开发一个微服务
- 号段耗尽风险：若步长设置不合理（过小），可能频繁申请号段；若过大，宕机后会浪费部分 ID；
- 数据库依赖：最终仍依赖数据库存储号段，需保证数据库高可用（主从 + 容灾）。

适用场景：
- 高并发、对 ID 有序性有要求的场景（如电商订单、支付交易）；
- 需按业务类型隔离 ID 的分布式系统（如多业务线共用 ID 服务）。

拓展优化：
- 双缓存优化：同时缓存当前号段和下一个号段，避免单号段耗尽时的阻塞；
- **动态步长**：根据业务 QPS 调整`step`（高 QPS 时增大步长，减少数据库访问；低 QPS 时减小步长，避免 ID 浪费）；

### 1.3.3 基于Redis模式
`Redis`也同样可以实现，原理就是利用`redis`的 `incr`命令实现ID的原子性自增：
1. 按业务类型创建 Redis 键（如`order_id_seq`、`user_id_seq`）；
2. 每次生成 ID 时，调用`INCR key`，返回的结果即为唯一 ID；
3. 为避免 Redis 重启后 ID 重置，需开启持久化（RDB+AOF 混合模式）。

优点
- 高性能：Redis 单节点 TPS 可达 10 万级，支持高并发；
- 实现简单：无需复杂逻辑，调用 Redis 命令即可；
- 有序性：同一号段内 ID 递增，全局趋势递增（满足大部分排序需求）；
- 支持分段：用`INCRBY key step`预分配号段（如一次申请 1000 个 ID），减少 Redis 访问次数；
- 多业务隔离：按 key 区分业务类型，互不干扰。

缺点
- 持久化风险：Redis 宕机、或主从切换后会丢失未同步的 ID，导致 ID 重复；
- 网络开销：需网络调用 Redis，性能略低于雪花算法。

适用场景：
- 高并发场景（TPS<10 万）：如普通电商订单、用户注册；
- 已有 Redis 集群，不想额外开发 ID 服务的场景；
- 对 ID 有序性有要求，但可容忍短暂无序的场景。

### 1.3.4 基于雪花算法（Snowflake）模式
雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法：
![[image-130.png]]
`Snowflake`生成的是Long类型的ID。
- 第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。
- 时间戳分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L << 41) / (1000部L * 60 * 60 * 24 * 365) = 69年
- 工作机器id（10bit）：也被叫做`workId`，这个可以灵活配置，机房或者机器号组合都可以。
- 序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID

优点
- 性能极高：纯内存计算，无网络 IO，TPS 可达百万级，支撑超高并发（如秒杀、直播场景）；
- 全局有序：按时间戳递增，同一毫秒内按序列号递增，满足排序需求；
- 无依赖：不依赖数据库、Redis 等第三方组件，部署简单；
- 可扩展：10 位机器 ID 支持多机房、多节点部署，扩容方便。

缺点
- 依赖时钟同步：节点间时钟必须一致（误差不能超过 1ms），否则时间慢的节点ID顺序会小于快的节点，导致全局 ID 顺序混乱；
- 时间回拨风险：若节点时钟回拨（如 NTP 同步、服务器重启），可能生成重复 ID；
- 机器 ID 分配：需中心化管理机器 ID（如配置中心、ZK），避免冲突；

拓展优化：
1. **时间回拨避免**：
	- **NTP 同步**：部署高可靠的 NTP 服务，减少时钟漂移
	- **双时间源**：同时使用本地时钟和外部时间源（如 GPS），增强可靠性
2. **时间回拨处理**（面试官高频追问）：
    - 轻微回拨（<10ms）：利用`time.Sleep`等待时钟追赶至最后生成 ID 的时间戳，再继续生成；
    - 中度回拨（10ms~1s）：维护一个全局变量`lastTimestamp`，回拨时直接用`lastTimestamp+1`作为当前时间戳，序列号重置为 0，避免重复；
    - 严重回拨（>1s）：触发 Prometheus 告警，人工介入排查时钟问题（如 NTP 同步异常），同时暂停该节点 ID 生成，避免大量 ID 浪费。；
3. **机器 ID 动态分配**：用 ZooKeeper 创建临时节点，节点 ID 作为机器 ID，服务启动时自动分配，下线时释放；
4. **去中心机器 ID 分配**：通过`syscall.Getpid()`结合机器 IP 生成临时机器 ID（适合无配置中心场景）；
5. **调整位分配**：如高并发场景下，将 10 位机器 ID 拆分为 8 位，序列号扩展为 14 位，提升单节点每秒生成量。

### 1.3.5 复合 ID 方案（业务定制化）
结合业务场景，将 “固定前缀 + 时间戳 + 随机数 / 机器 ID + 序列号” 组合生成 ID，示例：
- 订单 ID：`ORDER_20240520_10086_456`（前缀 + 日期 + 用户 ID + 随机数）；
- 物流单号：`LOG_20240520_001_789`（前缀 + 日期 + 机房 ID + 序列号）。

优点
- 可读性强：包含业务信息，便于人工排查问题（如从订单 ID 直接看出日期和用户）；
- 业务隔离：前缀区分业务类型，避免跨业务 ID 冲突；
- 灵活性高：可根据业务需求调整组成部分（如添加地区码、渠道码）。

缺点
- 长度较长：字符串型 ID，存储开销大，索引效率低；
- 有序性依赖组件：时间戳保证趋势有序，但随机数部分可能破坏局部有序；
- 需手动保证唯一性：需结合雪花算法、Redis 自增等组件，避免重复。

适用场景
- 对 ID 可读性要求高的场景：如物流单号、订单号（客服需快速识别）；
- 业务定制化需求强的场景：如多渠道、多地区的业务系统。

面试加分点
- 优化方案：用数字代替字符串前缀（如`10_20240520_10086_456`，10 代表订单业务），减少存储开销；
- 唯一性保证：复合 ID 的核心部分（如序列号）通过雪花算法生成，确保全局唯一。

### 1.3.6 方案对比
| 方案          | 唯一性 | 有序性 | 性能      | 可用性 | 实现复杂度 | 适用场景            |
| ----------- | --- | --- | ------- | --- | ----- | --------------- |
| UUID        | 高   | 低   | 极高      | 高   | 极低    | 无需有序、快速开发场景     |
| 数据库自增 ID    | 高   | 高   | 低（万级）   | 低   | 极低    | 低并发、简单分布式系统     |
| 号段模式        | 高   | 高   | 中（十万级）  | 高   | 中     | 高并发、有序性要求高      |
| Redis 自增 ID | 高   | 中   | 中（十万级）  | 中   | 低     | 高并发、已有 Redis 集群 |
| 雪花算法        | 高   | 高   | 极高（百万级） | 高   | 低 - 中 | 超高并发、无第三方依赖     |
| 复合 ID       | 高   | 中   | 中       | 高   | 中     | 可读性要求高、业务定制化场景  |

## 1.4 常见问题
- 雪花算法的时间回拨怎么解决？看雪花算法一节的拓展优化
- 号段模式的步长怎么设置？看号段模式一节的拓展优化
- UUID 为什么不适合做订单 ID？
	- 无序性：订单 ID 需要按时间排序，便于查询历史订单、统计销量，UUID 是随机字符串，排序效率低；
	- 存储开销：UUID 是 36 位字符串，并且无序，数据库索引效率低；
	- 可读性差：订单 ID 可能需要客服人工查询，UUID 字符串不便于记忆和输入，而雪花算法生成的数字 ID 更友好。
- 分布式 ID 如何避免泄露业务量级？核心是避免生成连续 ID
	- 雪花算法：虽然趋势递增，但同一毫秒内有 4096 个序列号，无法精准猜测业务量级；
	- UUID：随机字符串，完全无法推断；
	- 复合 ID：在 ID 中加入随机数或无关业务的标识（如地区码），掩盖真实递增规律；
	- 号段模式：步长设置为不固定值，或在 ID 中加入偏移量（如每个号段起始值 + 随机数）。

## 1.5 开源实现
### 1.5.1 百度（uid-generator）
`uid-generator`是由百度技术部开发，项目GitHub地址 [https://github.com/baidu/uid-generator](https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Fbaidu%252Fuid-generator)。
`uid-generator`是基于`Snowflake`算法实现的，与原始的`snowflake`算法不同在于，`uid-generator`支持`自定义时间戳`、`工作机器ID`和 `序列号` 等各部分的位数，而且`uid-generator`中采用用户自定义`工作机器ID`的生成策略。

### 1.5.2 美团（Leaf）
`Leaf`由美团开发，github地址：[https://github.com/Meituan-Dianping/Leaf](https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252FMeituan-Dianping%252FLeaf)  
`Leaf`同时支持号段模式和`snowflake`算法模式，可以切换使用。

#### 1.5.2.1 号段模式
先导入源码 [https://github.com/Meituan-Dianping/Leaf](https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252FMeituan-Dianping%252FLeaf) ，在建一张表leaf_alloc：
```sql
DROP TABLE IF EXISTS `leaf_alloc`;

CREATE TABLE `leaf_alloc` (
  `biz_tag` varchar(128)  NOT NULL DEFAULT '' COMMENT '业务key',
  `max_id` bigint(20) NOT NULL DEFAULT '1' COMMENT '当前已经分配了的最大id',
  `step` int(11) NOT NULL COMMENT '初始步长，也是动态调整的最小步长',
  `description` varchar(256)  DEFAULT NULL COMMENT '业务key的描述',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '数据库维护的更新时间',
  PRIMARY KEY (`biz_tag`)
) ENGINE=InnoDB;
```

然后在项目中开启`号段模式`，配置对应的数据库信息，并关闭`snowflake`模式：
```properties
leaf.name=com.sankuai.leaf.opensource.test
leaf.segment.enable=true
leaf.jdbc.url=jdbc:mysql://localhost:3306/leaf_test?useUnicode=true&characterEncoding=utf8&characterSetResults=utf8
leaf.jdbc.username=root
leaf.jdbc.password=root

leaf.snowflake.enable=false
#leaf.snowflake.zk.address=
#leaf.snowflake.port=
```

#### 1.5.2.2 snowflake模式
`Leaf`的snowflake模式依赖于`ZooKeeper`，`Leaf`中`workId`是基于`ZooKeeper`的顺序Id来生成的。每个应用在使用`Leaf-snowflake`时，启动时都会都在`Zookeeper`中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个`workId`。

### 1.5.3 滴滴（Tinyid）
`Tinyid`由滴滴开发，Github地址：[https://github.com/didi/tinyid](https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Fdidi%252Ftinyid)。
`Tinyid`是基于号段模式原理实现的，与`Leaf`如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]

## 1.6 总结
- 分布式ID就是在分布式环境下，生成一个全局唯一的ID
- 数据库号段模式：
	- 在数据库中建一张表，包含业务线、最大ID、步长、版本号字段。
	- 初始化时申请一个号段（例如1000-2000），然后有请求时就内存分配。号段快用完了就重新从数据库申请。
	- 高性能：数据库访问少，能支持10W并发；有序性；业务隔离
	- 拓展优化：
		- 动态步长：根据QPS决定步长大小
		- 避免泄漏业务量级：号段内起始点和步长随机，避免生成连续ID
- Redis模式：
	- 和数据库号段模式类似，只不过用Redis的Incr命令实现
	- 也可以实现高性能、有序性、业务隔离。但有持久化风险，可能导致ID重复
- 雪花算法
	- 结构：41位毫秒时间戳（支持69年）+10位机器ID+12位序列号（每一毫秒支持4096个ID）
	- 高性能（百万QPS），有序性，无依赖
	- 拓展优化：
		- 时间回拨处理：记录最后一次分配的ID，发现时间回拨时，在前面ID时间+1继续分配，直到时间正常
		- 机器ID分配：可以用ZooKeeper实现全局唯一；或者用线程ID+机器IP等方法去中心化生成唯一指纹
		- 避免泄漏业务量级：虽然趋势递增，但同一毫秒内有 4096 个序列号，无法精准猜测业务量级；
- 复合模式：
	- 将 “固定前缀 + 时间戳 + 随机数 / 机器 ID + 序列号” 组合生成 ID
	- 它包含业务信息，便于人工排查问题

---
# 2 引用
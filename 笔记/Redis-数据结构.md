2025-04-30 11:15
Status: #idea
Tags: [[Redis]]


# 1 数据结构基础
你肯定会说：“这个我知道，不就是 **String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）** 吗？”其实，这些只是 Redis 键值对中值的数据类型，也就是数据的保存形式。而这里，我们说的数据结构，是要去看看它们的底层实现。
简单来说，**底层数据结构**一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：
![[image-114.png]]

## 1.1 键和值用什么结构组织？
为了实现从键到值的快速访问，**Redis 使用了一个哈希表来保存所有键值对**。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。
哈希桶中的 `entry` 元素中保存了 `*key` 和 `*value` 指针，分别指向了实际的键和值：
![[image-115.png]]

当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是**哈希表的冲突问题和 rehash 可能带来的操作阻塞**。

### 1.1.1 为什么哈希表操作变慢了？
Redis 解决哈希冲突的方式，就是**链式哈希**。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。
所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 `entry` 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。

### 1.1.2 两个全局哈希表和渐进式哈希
为了使 rehash 操作更高效，**Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2**。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：
1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。
原来的哈希表 1 留作下一次 rehash 扩容备用。

这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了**渐进式 rehash**。
在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries：
![[image-116.png]]

渐进式 rehash 执行时，除了根据键值对的操作来进行数据迁移，**Redis 本身还会有一个定时任务在执行 rehash**，如果没有键值对操作时，这个定时任务会周期性地（例如每 100ms 一次）搬移一些数据到新的哈希表中，这样可以缩短整个 rehash 的过程。

## 1.2 数据结构简介
哈希表的操作特点我们刚刚已经学过了；整数数组和双向链表也很常见，它们的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问。

### 1.2.1 压缩列表
压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 `zlbytes`、`zltail` 和 `zllen`，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 `zlend`，表示列表结束。
![[image-117.png]]
在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。
[压缩列表详解](https://www.cnblogs.com/chenchen0618/p/13260202.html)。

### 1.2.2 跳表
**跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位**，如下图所示：
![[image-118.png]]
当数据量很大时，跳表的查找复杂度就是 O(logN)。
[跳表详解。](https://blog.csdn.net/qq_33774822/article/details/106852807)

### 1.2.3 为什么要有整数数组和压缩列表？
两方面原因：
1. **内存利用率**，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。
2. **数组对 CPU 高速缓存支持更友好**，所以 Redis 在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。

## 1.3 不同操作的复杂度
我总结了一个“四句口诀”，希望能帮助你快速记住集合常见操作的复杂度。这样你在使用过程中，就可以提前规避高复杂度操作了。
1. 单元素操作是基础；
2. 范围操作非常耗时；
3. 统计操作通常高效；
4. 例外情况只有几个。

### 1.3.1 单元素操作
单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。例如，`Hash` 类型的 `HGET`、`HSET` 和 `HDEL`，`Set` 类型的 `SADD`、`SREM`、`SRANDMEMBER` 等。这些操作的复杂度由集合采用的数据结构决定，例如，`HGET`、`HSET` 和 `HDEL` 是对哈希表做操作，所以它们的复杂度都是 O(1)；`Set` 类型用哈希表作为底层数据结构时，它的 `SADD`、`SREM`、`SRANDMEMBER` 复杂度也是 O(1)。

集合类型支持同时对多个元素进行增删改查，例如 `Hash` 类型的 `HMGET` 和 `HMSET`，Set 类型的 `SADD` 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，`HMSET` 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。

### 1.3.2 范围操作
范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 `Hash` 类型的 `HGETALL` 和 `Set` 类型的 `SMEMBERS`，或者返回一个范围内的部分数据，比如 `List` 类型的 `LRANGE` 和 `ZSet` 类型的 `ZRANGE`。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。
不过，Redis 从 2.8 版本开始提供了 `SCAN` 系列操作（包括 `HSCAN`，`SSCAN` 和 `ZSCAN`），这类操作实现了**渐进式遍历**，每次只返回有限数量的数据。这样一来，相比于 `HGETALL`、`SMEMBERS` 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。

### 1.3.3 统计操作
统计操作，是指集合类型对集合中所有元素个数的记录，例如 `LLEN` 和 `SCARD`。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。

### 1.3.4 例外情况
例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 `List` 类型的 `LPOP`、`RPOP`、`LPUSH`、`RPUSH` 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。

## 1.4 总结
- Redis常见的数据结构有:
	- String：简单动态字符串
	- List：压缩列表（数据量小）、双向链表
	- Hash：压缩列表、哈希表
	- Set：整数数组、哈希表
	- Sorted Set：压缩列表、跳表
- Redis 整体结构是个哈希表，解决哈希冲突的方式是拉链法
	- 有两个全局哈希表，第二个用在扩容rehash时。
	- Redis 采用渐进式 rehash 扩容：每处理一个命令时都顺带着把一部分键值对移到第二个哈希表中。Redis 本身还会有一个定时任务在执行 rehash。

# 2 数据结构的应用场景
## 2.1 核心数据结构（基础常用，高频面试）
1. **String**：可存储字符串、数字、二进制数据（如图片 Base64、序列化对象），最大容量 512MB。
	- 缓存热点数据（最核心场景）
	- 计数器（原子递增 / 递减）：支持原子操作：`incr/decr/incrby/decrby`（数字类型）
	- 分布式锁（基于 `set nx ex`）
	- Session 共享（分布式系统）
2. **Hash**（哈希表）：相比多个 String 键存储同一对象，Hash 更节省内存（Redis 对 Hash 有压缩存储优化）。
	- 存储对象类数据（核心场景）：替代 String 存储复杂对象，解决「修改单个字段需重新序列化整个对象」的问题。
	- 键值对场景，类似map
3. **List**（列表）：两端操作高效，支持阻塞操作 `blpop/brpop`
	- 简单消息队列（FIFO）
		- 优势：实现简单，支持阻塞消费，避免空轮询浪费资源。
		- 局限：无消息确认（ACK）、无消费组，消息丢失无法恢复（需结合持久化），复杂场景用 Stream。
	- 最新列表 / 时间线：展示最新数据（如朋友圈、新闻、评论），只保留最近 N 条。
4. **Set**（集合）
	- 数据去重：避免重复数据存储，如浏览记录、搜索历史。
	- 好友关系 / 社交关系：存储用户的好友、关注、粉丝列表，支持关系计算。
		- 好友列表：`key = friend:user1001`，添加好友 `sadd friend:user1001 user1002 user1003`。
		- 共同好友：`sinter friend:user1001 friend:user1002`（用户 1001 和 1002 的共同好友）。
		- 我关注的人但他没关注我：`sdiff follow:user1001 fan:user1001`。
		- 好友推荐：`sunion friend:user1001 friend:user1002`（用户 1001 的好友的好友）。
	- 标签系统：给内容（文章、商品）打标签，支持按标签筛选、推荐相似内容。
	- 抽奖系统
		- 参与抽奖：`sadd lottery:20251126 user1001 user1002 ...`。
		- 随机抽 1 人（不删除，可重复抽）：`srandmember lottery:20251126 1`
		- 随机抽 1 人（删除，不可重复抽）：`spop lottery:20251126 1`
5. **Sorted Set**（ZSet，有序集合）：范围查询高效，支持分数修改
	- 排行榜（核心场景）：按分数（销量、积分、点赞数）排序的榜单，支持实时更新。
	- 延迟队列：处理需要延迟执行的任务（如订单超时未支付取消、优惠券过期提醒）。
		- 结构：`key = delay:order`，`member = 订单ID`，`score = 订单过期时间戳（如 1753689600）`。
	    - 生产者：创建订单时 `zadd delay:order 1753689600 order1001`
	    - 消费者：定时（如每 10 秒）执行 `zrangebyscore delay:order 0 当前时间戳`，获取已过期订单，处理后 `zrem delay:order order1001`
	- 范围查询：按分数区间筛选数据，如积分等级、价格区间。

### 2.1.1 总结
1. String：字符串或二进制缓存、计数器、分布式锁、Session
2. Hash：对象、map
3. List：最新列表/时间线、简单消息队列
4. Set：去重、好友关系、标签、抽奖系统
5. Sorted Set：排行榜、范围查询（如价格区间）

## 2.2 特殊数据结构（针对性场景，高效解决特定问题）
1. BitMap（位图）：本质是 String：按「位」存储数据，每个 bit 代表一个状态（0 = 否，1 = 是），存储 1000 万条状态仅需 1.25MB。位运算高效：支持 `AND/OR/XOR/BITCOUNT`（统计 1 的个数）、`GETBIT`（查询某位置状态）、`SETBIT`（修改某位置状态）。
	- 布隆过滤器：快速判断元素是否不存在（如缓存穿透防护），底层由 BitMap + 多个哈希函数组成。布隆过滤器有「假阳性」（误判存在），无「假阴性」（不存在一定返回不存在）。
	- 用户在线状态：统计当前在线人数、查询单个用户是否在线。
		- `key = online:20251126`（按日期存储），`offset = 用户ID`（如用户 1001 对应 offset=1001）。
		- 上线：`setbit online:20251126 1001 1`。
		- 下线：`setbit online:20251126 1001 0`。
		- 查询用户 1001 是否在线：`getbit online:20251126 1001`。
		- 统计在线人数：`bitcount online:20251126`。
	- 签到功能：记录用户每日签到状态，统计签到次数、连续签到天数。
2. HyperLogLog（基数统计）：统计「不重复元素的个数」（基数），不存储具体元素，无论数据量多大（100 万、1 亿），占用内存约 12KB。误差率约 0.81%，可通过调整参数降低误差。
	- UV 统计（核心场景）：统计网站 / 页面的独立访客数（UV），无需存储每个访客的 ID。
	- 独立 IP / 设备统计：统计接口调用的独立 IP 数、APP 的独立设备数。
	- 行为分析：统计用户点击某按钮的独立次数、浏览某类商品的独立用户数。
3. Geospatial（GEO，地理位置）：存储经纬度（如北京 116.40°E，39.90°N），支持距离计算（`geodist`）、范围查询（`georadius`/`georadiusbymember`）、获取坐标（`geopos`）
	- 附近的人 / 商家（核心场景）：根据用户当前位置，查找附近的人、外卖商家、门店。
	- 地理位置围栏：判断用户是否在指定区域内（如景区、配送范围）。
4. Stream（流，Redis 5.0+）：专业消息队列，支持多生产者、多消费者、消费组（Consumer Group）、消息持久化、ACK 确认、消息唯一 ID。
	- 高可靠消息队列（核心场景）：替代 List 实现复杂消息队列，如订单系统、支付回调、日志收集。
	- 日志收集：多个服务将日志写入 Stream，消费组按业务分类处理（如错误日志、访问日志）。

# 3 数据结构底层原理
## 3.1 String
Redis 所有 String 类型的底层存储（除整数编码外）均基于**简单动态字符串（SDS）** 实现。SDS 是 Redis 自定义的字符串抽象结构，目的是解决 C 原生字符串的诸多缺陷。

### 3.1.1 SDS 的结构体定义
Redis 3.2 版本后对 SDS 进行了优化，根据字符串长度不同，设计了 5 种不同的结构体（`sdshdr5`/`sdshdr8`/`sdshdr16`/`sdshdr32`/`sdshdr64`），核心是按字符串长度选择合适的字段类型，减少内存浪费。
所有 SDS 结构体的核心字段一致，仅 `len`（已用长度）、`alloc`（总容量）的类型不同，且通过 `flags` 标识结构体类型。
```c
// 宏定义：通过 flags 的低 3 位标识 SDS 类型
#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4

// 1. 用于长度 ≤ 31 的字符串（5 位足够存储 len，无单独 len/alloc 字段）
struct __attribute__((__packed__)) sdshdr5 {
    unsigned char flags;  // 低 3 位 = 类型（SDS_TYPE_5），高 5 位 = 字符串长度 len
    char buf[];           // 柔性数组，存储字符串内容 + 末尾 '\0'（兼容 C 函数）
};

// 2. 用于长度 ≤ 255 的字符串（uint8_t = 1 字节）
struct __attribute__((__packed__)) sdshdr8 {
    uint8_t len;          // 已使用字节数（不含 '\0'）
    uint8_t alloc;        // 总容量（不含 header + '\0'）
    unsigned char flags;  // 低 3 位 = 类型（SDS_TYPE_8），高 5 位保留
    char buf[];           // 存储字符串内容 + '\0'
};

// 3. 用于长度 ≤ 65535 的字符串（uint16_t = 2 字节）
struct __attribute__((__packed__)) sdshdr16 {
    uint16_t len;
    uint16_t alloc;
    unsigned char flags;
    char buf[];
};

// 4. 用于长度 ≤ 2^32-1 的字符串（uint32_t = 4 字节）
struct __attribute__((__packed__)) sdshdr32 {
    uint32_t len;
    uint32_t alloc;
    unsigned char flags;
    char buf[];
};

// 5. 用于长度 ≤ 2^64-1 的字符串（uint64_t = 8 字节）
struct __attribute__((__packed__)) sdshdr64 {
    uint64_t len;
    uint64_t alloc;
    unsigned char flags;
    char buf[];
};
```
关键字段说明：
- `len`：字符串已使用的字节数（不含末尾的 '\0'），直接获取长度时无需遍历，O (1) 时间复杂度。
- `alloc`：字符串的总容量（不含 SDS 头部 + 末尾 '\0'），即 `alloc = len + free`（`free` 是空闲字节数）。
- `flags`：1 字节，低 3 位标识 SDS 类型（如 `sdshdr8` 对应 `flags=0x08`），高 5 位保留，用于快速判断 SDS 结构体类型。
- `buf`：柔性数组（C99 特性），存储字符串实际内容，末尾自动添加 `'\0'`（兼容 C 语言字符串函数，如 `strcpy`、`printf`）。
- `__attribute__((__packed__))`：强制结构体紧凑存储，避免内存对齐导致的空间浪费（例如 `sdshdr8` 头部仅 3 字节，而非 4 字节）。

### 3.1.2 优点
相比于C语言原生字符串：
1. O (1) 时间获取字符串长度
2. 减少内存重分配次数（预分配 + 惰性释放）
	- 若扩容后 `len < 1MB`：空闲空间 `free = len`（即总容量 `alloc = len * 2`）
	- 若扩容后 `len ≥ 1MB`：空闲空间 `free = 1MB`（避免过大字符串占用过多空闲内存）
	- 当 SDS 长度缩短时（如 `sdstrim` 截断字符串），Redis 不会释放多余内存
3. 二进制安全：用 `len` 判断结束，可存图片 / 视频等二进制数据
4. 兼容 C 函数

### 3.1.3 Redis String 对象的编码优化
Redis 中所有数据都以「对象（`redisObject`）」的形式存储，String 类型对应的对象结构如下：
```c
typedef struct redisObject {
    unsigned type:4;        // 对象类型（OBJ_STRING/OBJ_LIST/OBJ_HASH 等）
    unsigned encoding:4;    // 编码方式（OBJ_ENCODING_INT/EMBSTR/RAW）
    unsigned lru:LRU_BITS;  // LRU 缓存淘汰相关（24 位）
    int refcount;           // 引用计数（内存回收 + 共享对象）
    void *ptr;              // 指向底层存储（整数/SDS）
} robj;
```

String 对象的 `encoding` 字段有三种编码方式，Redis 会根据字符串的「长度」和「类型」自动切换，核心目标是**节省内存**：
- `OBJ_ENCODING_INT`（**整数编码**）
	- 适用场景：字符串是 64 位有符号整数，长度 ≤20 字节，64 位整数的十进制最大长度为 20 位
	- 底层存储：直接存储整数（`ptr` 指向整数本身）
	- 内存效率：最高（无需 SDS 头部开销）
- `OBJ_ENCODING_EMBSTR`（**嵌入式编码**）
	- 适用场景：字符串长度 ≤44 字节（Redis 3.2+）。Redis 内存分配器（默认 jemalloc）按「固定大小块」分配内存（如 8、16、32、64、128 字节），所以需适配最小的「能容纳完整结构」的块（64 字节）：
		- `redisObject` 大小：16 字节（type (4bit)+encoding (4bit)+lru (24bit)+refcount (4B)+ptr (8B)）；
		- `sdshdr8` 头部：3 字节（len (1B)+alloc (1B)+flags (1B)）；
		- 末尾 `'\0'`：1 字节；
		- 剩余可存储字符串的长度：`64 - 16 - 3 - 1 = 44` 字节。
	- 底层存储：`redisObject` + `sdshdr8` 连续内存
	- 内存效率：高（1 次内存分配）
- `OBJ_ENCODING_RAW`（**原始编码**）
	- 适用场景：字符串长度 >44 字节，支持超长字符串（最大 512MB，Redis 限制，而非 SDS 本身限制）。
	- 底层存储：`redisObject` + 独立 SDS 内存
	- 内存效率：较低（2 次内存分配）

注意：编码仅支持「从高效到低效」切换（`INT→RAW`、`EMBSTR→RAW`），反之不会自动切换（如 `SET raw "123"` 若原编码是 `RAW`，不会自动切换为 `INT`）。

### 3.1.4 关键辅助机制
#### 3.1.4.1 引用计数（refcount）
`redisObject` 的 `refcount` 字段用于内存回收和对象共享：
- 当多个键共享同一个字符串对象时（如 `SET a "hello"`、`SET b "hello"`），`refcount` 递增（初始为 1，共享后为 2）；
- 当键被删除时，`refcount` 递减；当 `refcount=0` 时，释放 `redisObject` 和底层 SDS / 整数内存；
- 优点：减少相同字符串的内存占用（如频繁使用的小字符串可共享）。

#### 3.1.4.2 写时复制（Copy-On-Write）
当共享的字符串对象被修改时（如 `SET a "world"`，而 `a` 和 `b` 原本共享 `"hello"`），Redis 会触发「写时复制」：
- 检查 `refcount`：若 `refcount > 1`，则复制一个新的字符串对象（SDS / 整数）；
- 修改新对象：将原键的 `ptr` 指向新对象，`refcount` 设为 1；
- 原对象 `refcount` 递减：若 `refcount=0`，则释放原对象内存；
- 优点：避免修改共享对象影响其他键，同时延迟复制开销。

### 3.1.5 总结
- String 的底层结构是简单动态字符串（SDS），它是一个结构体，存有长度、容量、实际的字符串、flag字段。并且根据字符串长度的不同，有多种结构体，减少内存浪费。
- SDS 支持O(1)获取长度、预分配减少内存分配次数、二进制安全、兼容C函数
- SDS 针对不同长度的字符串，对 RedisObject 有不同的编码优化，RedisObject 是Redis 中所有数据的存储结构
	- 64位整数，有整数编码，不需要SDS结构体头部开销
	- 字符串长度<=44字节，有嵌入式编码，RedisObject和SDS可以在一次内存分配中完成
	- 否则用原始编码，此时RedisObject和SDS是独立分配内存的
- SDS 还会共享相同的字符串，这是通过RedisObject中的refcount实现

---
# 4 引用
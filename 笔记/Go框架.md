2025-06-18 16:22
Status: #idea
Tags:

# 1 hertz路由原理
Hertz 框架的路由原理主要基于前缀树（Prefix Tree，也称Trie树）来实现高效的路由匹配。当接收到HTTP请求时，Hertz会根据请求的URL路径在树形结构中进行查找，找到最匹配的处理函数。
以下是Hertz路由原理的更详细解释：
1. 前缀树结构:
	- Hertz使用前缀树来存储和管理路由。每个节点代表URL路径的一部分（例如，`/`，`users`，`posts`）。
	- 从根节点开始，每个节点的子节点代表该节点路径的下一个可能的路径段。
	- 通过这种结构，可以快速地查找匹配的路由，因为相同的URL前缀可以共享节点，减少了不必要的遍历。
2. 路由匹配过程:
	- 当一个请求到达Hertz时，框架会提取请求的URL路径。
	- 从前缀树的根节点开始，根据路径段逐层向下查找。
	- 如果当前节点有匹配的子节点，则沿着该子节点继续查找；如果没有匹配的子节点，则表示没有找到匹配的路由。
	- 如果找到一个与URL路径完全匹配的节点，则表示找到了匹配的路由，并执行相应的处理函数。
	- 在匹配过程中，Hertz还会处理一些特殊情况，例如：
	    - **尾部斜杠处理:** Hertz默认会自动处理尾部斜杠，根据路由定义自动重定向。
	    - **参数路由:** 支持类似 `/users/:id` 这样的带参数的路由，在匹配时会提取参数值。﻿
3. 中间件:
	- Hertz支持中间件机制，可以在请求到达路由处理函数之前或之后执行一些通用逻辑，例如权限验证、日志记录等。
	- 中间件可以看作是添加到路由匹配过程中的额外处理步骤。

# 2 Thrift
## 2.1 简介
Thrift 是 Facebook 开源的**跨语言 RPC 框架**，核心目标是解决不同语言服务间的高效通信问题。它通过统一的 IDL（接口定义语言）定义服务和数据结构，生成多语言桩代码，结合灵活的序列化 / 传输 / 服务模型，实现高性能跨语言 RPC。

## 2.2 核心原理
Thrift 采用分层架构（自下而上），每层可灵活替换，这是其跨语言、高性能的核心：

| 层级           | 核心作用               | 关键实现 / 考点                                                       |
| ------------ | ------------------ | --------------------------------------------------------------- |
| IDL 层        | 统一定义数据结构 / 服务接口    | 语法（结构体 / 服务 / 字段 ID）、字段 ID 的作用（减少传输体积、兼容字段扩展）                   |
| Protocol 层   | 序列化 / 反序列化（内存↔字节流） | TBinaryProtocol（二进制，高性能）、TCompactProtocol（压缩）、TJSONProtocol（调试） |
| Transport 层  | 网络传输字节流            | TFramedTransport（帧化传输，解决 TCP 粘包）、TSocket（基础 TCP）                |
| Server Model | 服务端请求处理模型          | TThreadPoolServer（线程池）、THsHaServer（半同步半异步）；Kitex 优化为协程模型        |

## 2.3 核心流程
以 “客户端调用 GetUser” 为例：
1. 客户端调用 Stub 方法→Protocol 序列化参数；
2. Transport（如 TFramedTransport）加长度前缀→TCP 发送；
3. 服务端 Transport 拆帧→Protocol 反序列化参数；
4. 服务端 Skeleton 调用业务逻辑→序列化返回值；
5. 传输回客户端→反序列化得到结果。

## 2.4 关键考点解析
### 2.4.1 Thrift 的核心优势是什么？
1. 跨语言：统一 IDL 支持多语言；
2. 高性能：二进制序列化 + 帧化传输；
3. 灵活：每层可替换（如切换序列化协议）；
4. 一站式：内置传输 / 服务模型，无需重复造轮子。

### 2.4.2 Thrift IDL 中字段 ID 的作用？
1. 替代字段名传输，减少字节体积；
2. 兼容字段扩展：新增字段只要 ID 不重复，老版本不会报错；
3. 序列化时通过 ID 映射字段，不依赖字段顺序。

### 2.4.3 Thrift 如何解决 TCP 粘包？
TCP 是流式协议，粘包是因为请求无边界。Thrift 通过 TFramedTransport 给每个请求加 4 字节长度前缀，服务端先读长度再读数据，精准拆分。

#### 2.4.3.1 TCP粘包 / 拆包到底是什么
首先要明确TCP 的核心特性：**TCP 是「流式协议」**，而非「数据包协议」（比如 UDP）。
可以把 TCP 连接想象成一根 “水管”，数据是水管里的 “水流”—— 水流本身没有天然的 “分段边界”，你往水管里倒 3 杯水（3 个请求），另一端接水时，可能收到：
- 「粘包」：一次性接到 3 杯水混在一起（多个请求的数据粘成一段）；
- 「拆包」：1 杯水被拆成 2 次接（一个请求的数据被拆成多段）
本质是**应用层无法区分 TCP 流中 “一个请求” 的开始和结束位置**。

粘包 / 拆包的核心原因：
1. **发送端**：TCP 有 Nagle 算法（合并小数据包发送，减少网络交互），会把多个小请求合并成一个 TCP 包发送；
2. **接收端**：TCP 有接收缓冲区，数据先存缓冲区，应用层读取不及时的话，缓冲区会堆积多个请求的数据；
3. **网络层面**：数据包在网络中可能被分片 / 重组，导致边界丢失。

举个具体例子：客户端连续调用 2 次`GetUser(1)`和`GetUser(2)`，发送的数据是`[数据1][数据2]`，TCP 传输后，服务端可能收到：
- 粘包：`[数据1+数据2]`（一次读到 2 个请求）；
- 拆包：`[数据1的前半部分]` + `[数据1的后半部分+数据2]`（两次读取，第一次不完整，第二次混了两个请求）；
如果没有边界标识，服务端根本分不清哪段是第一个请求、哪段是第二个。

#### 2.4.3.2 FramedTransport 解决粘包的详细机制
核心思路是：**给每个请求 / 响应加「帧头（长度前缀）」，让应用层能通过 “长度” 识别请求边界**。

##### 2.4.3.2.1 帧的结构（关键）
`TFramedTransport`会把每个请求封装成一个「帧（Frame）」，结构如下：
- 「4 字节长度前缀」：固定占 4 个字节，用**大端序（网络字节序）** 存储，值是「数据体的字节数」；
- 「数据体」：Thrift Protocol 层序列化后的请求数据（比如`GetUser(1)`的二进制数据）。

##### 2.4.3.2.2 发送端（客户端 / 服务端响应时）的处理流程
1. 客户端调用`GetUser(1)`，Thrift 先通过 Protocol 层把参数序列化成二进制数据（比如长度 16 字节）；
2. `TFramedTransport`接收这个 16 字节的数据体，计算长度（16）；
3. 把长度 16 转换成 4 字节的大端序二进制（比如`0x00 0x00 0x00 0x10`）；
4. 把「4 字节长度前缀 + 16 字节数据体」拼接成 20 字节的帧，通过 TCP 发送出去；

##### 2.4.3.2.3 接收端（服务端 / 客户端）的拆帧流程
1. 接收端先从 TCP 缓冲区读取**前 4 字节**（长度前缀）；
2. 把 4 字节的大端序数据转换成十进制数字（比如 16），这个数字就是 “当前请求的数据体长度”；
3. 根据这个长度（16），从 TCP 缓冲区读取接下来的 16 字节，这就是完整的一个请求数据体；
4. 如果 TCP 缓冲区还有剩余数据，重复 Step1-Step3，处理下一个帧；

这样，即使多个帧粘在一起（比如`[帧1][帧2]`），也能通过 “先读长度→再读对应字节” 精准拆分。

### 2.4.4 二进制协议为什么高效
二进制协议比 JSON 高效：无冗余字符（如 {}）、字段 ID 替代字段名、数值用 varint 紧凑编码”。

#### 2.4.4.1 varint 紧凑编码
##### 2.4.4.1.1 简介
常规的数值编码（比如 int32 固定占 4 字节、int64 固定占 8 字节）是「定长编码」—— 不管数值是 1（很小）还是 2147483647（int32 最大值），都占用相同字节数，这对小数值来说是极大的空间浪费。
varint（Variable-Length Integer，变长整数编码）是一种「变长编码方式」：**小数值用更少的字节存储，大数值用更多字节存储**，整体平均占用字节数远低于定长编码，这也是 Thrift 二进制协议高效的核心原因之一。

Thrift 中 varint 主要用于编码整数类型（i8/i16/i32/i64），比如：
- 数值 1 用 varint 编码仅占 1 字节（定长 int32 占 4 字节）；
- 数值 128 用 varint 编码占 2 字节（定长 int32 占 4 字节）；
- 数值 2^28-1 用 varint 编码占 4 字节（和定长 int32 持平）。

##### 2.4.4.1.2 varint 的核心原理
varint 编码的核心规则只有两条，非常简单：
1. **字节的最高位（第 8 位）是「续位标志」**：
	- 1 → 表示当前字节不是最后一个，后面还有字节需要拼接；
	- 0 → 表示当前字节是最后一个，结束拼接。
2. **每个字节的低 7 位是「有效数据位」**：
    - 数值的二进制会被拆分成若干个 7 位的片段；
    - 片段按「低位在前、高位在后」的顺序（小端序）填充到每个字节的低 7 位；
    - 最后一个字节的最高位设为 0，其余字节的最高位设为 1。

##### 2.4.4.1.3 ZigZag 编码
varint 本身只适合编码**非负整数**，但 Thrift 要处理负数。计算机中负数用「补码」表示，比如 int64 的 - 1，补码是`64个1`，如果直接用 varint 编码，会占满 8 字节（因为每字节最高位都是 1，直到最后一个字节），完全失去 varint “紧凑” 的意义。
ZigZag 的核心目的：**把正负整数「zigzag 式」映射到非负整数区间**，让负数也能像小正数一样用 varint 高效编码，同时保留 “区分正负” 的信息。

编码公式：
- 64 位整数（i64）：`ZigZag(n) = (n << 1) ^ (n >> 63)`
- 32 位整数（i32）：`ZigZag(n) = (n << 1) ^ (n >> 31)`
公式拆解：
- `n << 1`：把原数左移 1 位，空出最低位（用来存 “正负标记”）；
- `n >> 63`/`n >> 31`：符号位扩展 —— 正数右移结果是 0，负数右移结果是`-1`（补码中全 1）；
- `^`（异或）：把 “符号位扩展结果” 和 “左移后的数” 异或，最终让编码值的**最低位**成为 “正负标记”：
    - 原数为正 → 最低位 = 0（编码值是偶数）；
    - 原数为负 → 最低位 = 1（编码值是奇数）。

解码公式：`n = (zigzag >> 1) ^ -(zigzag & 1)`
- `zigzag >> 1`：把编码值右移 1 位，还原出原数的 “绝对值部分”；
- `zigzag & 1`：取编码值的最低位（0 = 偶 = 正，1 = 奇 = 负）；
- `-(zigzag & 1)`：最低位为 1 时结果是`-1`（全 1），为 0 时结果是 0；
- `^`（异或）：如果是负数，用`-1`异或 “绝对值部分” 还原补码；如果是正数，用 0 异或，值不变。

|原数 n|ZigZag 编码值（偶 / 奇）|编码过程（64 位）|解码过程|
|---|---|---|---|
|0|0（偶→正）|(0<<1) ^ (0>>63) = 0 ^ 0 = 0|(0>>1) ^ -(0&1) = 0 ^ 0 = 0|
|1|2（偶→正）|(1<<1) ^ (1>>63) = 2 ^ 0 = 2|(2>>1) ^ -(2&1) = 1 ^ 0 = 1|
|-1|1（奇→负）|(-1<<1) ^ (-1>>63) = -2 ^ -1 = 1|(1>>1) ^ -(1&1) = 0 ^ -1 = -1|
|2|4（偶→正）|(2<<1) ^ (2>>63) = 4 ^ 0 = 4|(4>>1) ^ -(4&1) = 2 ^ 0 = 2|
|-2|3（奇→负）|(-2<<1) ^ (-2>>63) = -4 ^ -1 = 3|(3>>1) ^ -(3&1) = 1 ^ -1 = -2|

ZigZag 编码后的数，**最低位是 0（偶数）→ 原数是正数；最低位是 1（奇数）→ 原数是负数**。

### 2.4.5 Thrift 和 Protobuf 的区别？
1. Thrift 是完整 RPC 框架，Protobuf 仅序列化协议（需配合 gRPC）；
2. Thrift IDL 更贴近业务（支持异常 / 服务定义），Protobuf 序列化效率略高

# 3 Kitex
## 3.1 简介
Kitex 是字节基于 Thrift 开发的**Go 专属 RPC 框架**，并非重构，而是对 Thrift 的 Go 实现做深度优化：
- 完全兼容 Thrift IDL：你写的 Kitex IDL 本质就是 Thrift IDL；
- 复用核心流程：IDL 定义→代码生成→客户端调用→服务端处理，完全继承 Thrift 逻辑；
- 优化性能：Kitex 自研更高效的序列化协议（兼容 Thrift）、协程化服务模型，解决原生 Thrift Go 版性能短板。

## 3.2 核心原理
### 3.2.1 Kitex对Thrift的沾包解决方法做了哪些优化？
Kitex 基于此优化：增加帧校验、超时控制，结合 Go 的 IO 多路复用（epoll）提升高并发拆帧效率，同时适配协程模型。
1. **帧校验增强**：在 4 字节长度前缀基础上，增加了「魔数 / 校验位」，防止恶意数据或网络异常导致的长度解析错误；
2. **超时控制**：接收端读取长度前缀 / 数据体时，增加超时机制（比如 3 秒没凑够数据就断开连接），避免长连接被无效数据阻塞；
3. **协程适配**：结合 Go 的协程模型，拆帧逻辑用非阻塞 IO 实现，一个协程可处理多个连接的拆帧，提升高并发下的效率；
4. **内存复用**：预分配帧缓冲区，避免频繁创建 / 销毁字节数组，减少 GC 开销（原生 Thrift 的 Go 版没有这个优化）。

### 3.2.2 Kitex 对 varint 的优化
Kitex 完全兼容 Thrift 的 varint 编码逻辑，还做了针对性优化：
1. **预计算常见数值的 varint 长度**：比如 1-127 这些高频字段 ID / 小数值，提前计算好编码长度，避免运行时重复计算，减少 CPU 开销；
2. **内存复用**：编码时复用 varint 缓冲区，避免频繁创建字节数组，降低 Go 的 GC 压力；
3. **批量编码优化**：对多个整数（比如批量字段 ID）做连续 varint 编码，减少 IO 调用次数。

### 3.2.3 原生 Thrift 和 Kitex 的服务模型有什么区别？
原生 Thrift 用线程池（TThreadPoolServer），适配 Java 但不贴合 Go 协程生态；Kitex 重构为协程池模型，基于 IO 多路复用处理请求，并发能力远高于原生，还集成了熔断、限流等治理能力。

---
# 4 引用
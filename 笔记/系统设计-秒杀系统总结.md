2025-10-28 16:04
Status: #idea
Tags: [[场景题和设计题]]

# 1 极客时间总结
## 1.1 概览
高可靠系统的三个维度：高可用，一致性，高性能。
实现高可靠的架构原则：
1. 数据尽量少：请求的上传和响应数据、系统依赖的数据都要少
2. 请求数尽量少
3. 路径尽量短：极致方法是合并部署
4. 强依赖尽量少：对系统分级，高级系统尽量减少对低级系统的强依赖
5. 不要有单点：通过无状态、或冗余备份（如数据库）实现

秒杀系统关键问题：并发读、并发写

秒杀业务流程：秒杀 -> 下单 -> 支付

秒杀系统架构：
- 秒杀详情系统
- 秒杀交易系统
- 商品、库存系统
- 支付系统

## 1.2 关键技术点
### 1.2.1 高可用
#### 1.2.1.1 隔离
- 业务隔离：让商家报名，使热点已知，方便提前预热
- 系统隔离：独立系统&集群
- 数据隔离：独立数据库、独立缓存

#### 1.2.1.2 流量削峰
答题：
- 防止用户刷接口
- 让流量基于时间分片
- **答题系统怎么抗住高并发？**

分层过滤：
- 在浏览器和CDN拦截大部分数据读取
- 第二层前台读系统，数据走Cache，过滤无效请求（库存没有了之后的请求）
- 第三层后台写系统，做数据的二次检验，对系统做好保护和限流
- 在数据层完成数据的强一致性校验

排队：
- 消息队列承接瞬时流量，把同步请求变成异步
- 也需要保护MQ，MQ之前应该有很多层限流, 其中可以考虑加一层抢令牌。 比如说我要放100个手机用于秒杀, 那么放10000个令牌给不同的用户, 足够了。其它的抢不到令牌的, 直接返回秒杀结束。

#### 1.2.1.3 降级
它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。

#### 1.2.1.4 限流
限流位置：
- **客户端限流**，好处可以限制请求的发出。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。
- **服务端限流**，好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。

限流的实现手段：
- **QPS限流**：最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。
- **线程数限流**：在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。

快速失败：限流必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。

#### 1.2.1.5 拒绝服务
当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2\*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。
这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。

### 1.2.2 一致性
#### 1.2.2.1 库存读的最终一致性
库存的读取（判断还有没有商品、要不要防请求进来）缓存没有必要极致追求数据的准确性，只要保证最终一致性。缓存本身为了减少数据库的压力。
最坏情况也就是多放了一些请求进来。

#### 1.2.2.2 库存扣减
库存扣减的方式：
1. 下单减库存：简单精准，但是有人可能恶意不支付。
	- 秒杀系统会用，因为秒杀下单不支付的现象是很少的
2. 付款减库存：会有库存超卖现象
3. 预扣库存：下单后库存为其保留一定的时间（如 10 分钟），超过库存将自动释放。一定程度防止恶意支付。这是业务系统常用方式
	- 但恶意买家完全可以在 10 分钟后再次下单，或者采用一次下单很多件的方式把库存减完。
	- 结合安全和反作弊的措施：
		- 给经常下单不付款的买家进行识别打标
		- 给某些类目设置最大购买件数
		- 以及对重复下单不付款的操作进行次数限制
		- ......

#### 1.2.2.3 下单和库存两个操作的事务怎么保证
背景：下单、库存操作分别是两个系统。
解决办法：
1. 两阶段提交：可以分两步来做，先创建订单但是先不生效，然后减库存，如果减库存成功后再生效订单，否则订单不生效。类似于MySQL日志的两阶段提交
2. 分布式事务

### 1.2.3 高性能
#### 1.2.3.1 性能影响因素
性能指标：
- **响应时间（Response Time，RT）**：服务器处理响应的耗时，由**CPU 执行时间**和**线程等待时间**（比如 RPC、IO 等待、Sleep、Wait 等）组成。
	- CPU 的执行真正消耗了服务器的资源，对性能影响最大
- **QPS（Query Per Second，每秒请求数）** =（1000ms / 响应时间）× 线程数量
- 线程数最佳实践：`线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量`。如果考虑超线程，还可以 x 2

发现瓶颈：
- 性能工具： JProfiler 和 Yourkit 这两个工具，它们可以列出整个请求中每个函数的 CPU 执行时间
- 压测：
	- 简单地判断 CPU 是不是瓶颈：一个办法就是看当 QPS 达到极限时，你的服务器的 CPU 使用率是不是超过了 95%。如果没有超过，那么表示 CPU 还有提升的空间，要么是有锁限制，要么是有过多的本地 I/O 等待发生。
	- 除了CPU，系统的每一个中间件, 每一台机器, 都应该有promethus监控大屏。系统到qps极限时, 查监控大屏上谁的的cpu/内存/磁盘/网络满了, 差不多就是瓶颈了。

做好应用基线：
- 比如性能基线（QPS、RT等，何时性能突然下降）、成本基线（去年双 11 用了多少台机器）、链路基线（依赖哪些关键接口，我们的系统发生了哪些变化）
- 你可以通过这些基线持续关注系统的性能，做到在代码上提升编码质量，在业务上改掉不合理的调用，在架构和调用链路上不断的改进。

#### 1.2.3.2 动静分离
动态静态分类：数据中是否含有和访问者相关的个性化数据。

静态数据
- 缓存地点要离用户近
- 让web型缓存（varnish）或CDN缓存
- 可以对URL的结果进行缓存。https协议的链接只在最外层，内部系统用http
- CDN要点
	- 离访问量大的地区近，离主站远但和主站的网络好
	- 节点容量大且数量不多，数量不多则访问量集中、命中率高
	- CDN作为二级缓存，没取到去一级缓存（web型缓存）
	- vs 浏览器。浏览器不可控，CDN可以主动失效

动态数据：
- ESI：web服务器做动态请求，把结果插入到页面中返回
- CSI：浏览器自己请求动态内容，对服务器友好，适合秒杀系统

#### 1.2.3.3 热点数据
热点数据发现
- 静态热点数据：就是能够提前预测的热点数据
- 动态热点数据发现系统
	- 收集交易链路上各个环节中的中间件产品的热点Key或抓取日志，如 Nginx、缓存、RPC 服务框架等这些中间件
	- 提供订阅给其他系统

热点数据缓存
- 更新方式
	- 定时更新
	- 主动更新：用阿里metaq技术，就是数据库字段更新会产生一条消息。让一个失效中心去监控，收到更新后给缓存发送失效请求
- 一致性：缓存没有必要极致追求数据的准确性，只要保证最终一致性。缓存本身为了减少数据库的压力。
- 单点问题
	- 冗余备份：当热点数据过热时，单个缓存也撑不住，需要弄多个实例缓存一样的内容，用nginx路由。用在web型缓存中
	- 本地缓存
- **缓存预热?**

热点数据限制：对被访问商品的 ID 做一致性 Hash，在部分服务调用的地方对请求进行 Hash 分组，每个分组设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。

热点数据隔离

#### 1.2.3.4 库存扣减实现
缓存扣减：
- 如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话，我觉得完全可以。
- 让redis定时将库存放到mysql中备份。redis挂了数据丢失也没关系，可以在重启时进行数据库里的订单商品数进行计算，计算出剩余库存，然后存到redis中。以数据库中的数据为准就好了。
- 但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。

MySQL扣减：需要解决热点商品占满数据库连接、和高并发抢锁的问题
- 热点商品动态迁移到单独库中
- 应用层做排队：按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量。
- 数据库层做排队：应用层只能做到单机的排队，但是应用机器数本身很多，可能一个商品在很多机器上都有队列，所以这种排队方式控制并发的能力仍然有限。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。

#### 1.2.3.5 减少数据库的更新操作
有些场景（如对商品的 lastmodifytime 字段的）更新会非常频繁，在某些场景下这些多条 SQL 是可以合并的，一定时间内只要执行最后一条 SQL 就行了。

### 1.2.4 用户体验
#### 1.2.4.1 异步请求怎么通知用户结果
以下方案：
1. 一是可以给前端一个查询接口，这种查询流量，因为后端完全知晓结果, 可以全部放到redis中(甚至local cache), 不会有穿透到DB的流量, 因此可以做到速度很快。缺点是服务端的请求数会增加不少。
2. 二是采用主动 push 的方式，这种就要求服务端和客户端保持连接了，服务端处理完请求主动 push 给客户端，这种方式的缺点是服务端的连接数会比较多。

异步的请求失败直接丢弃就好了，最坏的结果就是这个人没有抢到而已。

# 2 背景
秒杀一般出现在商城的促销活动中，指定了一定数量（比如：10个）的商品（比如：手机），以极低的价格（比如：0.1元），让大量用户参与活动，但只有极少数用户能够购买成功。

一般在秒杀时间点（比如：12点）前几分钟，用户并发量才真正突增，达到秒杀时间点时，并发量会达到顶峰。这个峰值持续的时间其实是非常短的，这样就会出现**瞬时高并发**的情况。

由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。这是非常典型的**读多写少**的场景。

秒杀流程：
![[image-134.png]]

# 3 概括
设计：
- redis预热库存
- redis预减库存
- MQ异步下单和最终扣减数据库库存

挑战&问题：
- 高并发
- 加了缓存之后的三大问题：击穿、穿透、雪崩
- 如何解决热点数据问题？单个商品过热，请求量可能redis都承受不住
- 防止用户重复秒杀
	- 前端限制：一次点击之后按钮置灰几秒钟
	- 后端限制：在redis中记录哪些用户已经秒杀过了
- 秒杀中如何处理超卖问题？
	- MySQL中的排他锁 `update` `table_prmo` `set` `num = num - 1` `WHERE` `id = 1001` `and` `num > 0`
	- redis单线程特性处理秒杀超卖
- 秒杀中如何解决重复下单问题？
	- 消费幂等性
- 库存扣减成功，下单失败（MQ消息失败）怎么办？
	- 回退库存
	- 分布式事务：将减库存与生成订单操作组合为一个事务
- 订单超时后如何取消
- 限流削峰措施
	- 验证码，分散同一时间下单的用户数量
	- 漏桶和令牌桶
	- 封用户ID、IP

# 4 页面静态化和CDN加速
活动页面是用户流量的第一入口，所以是并发量最大的地方。如果这些流量都能直接访问服务端，恐怕服务端会因为承受不住这么大的压力，而直接挂掉。
活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做**静态化处理**。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。

但只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，网速各不相同。这就需要使用CDN，让用户最快访问到活动页面。

# 5 缓存预热和缓存穿透
如果有数十万的请求过来，同时通过数据库查库存是否足够，此时数据库可能会挂掉。所以应该改用缓存，比如：redis。
在项目启动之前，先把缓存进行**预热**。即事先把所有的商品，同步到缓存中，这样商品基本都能直接从缓存中获取到。

如果查询的商品不存在，同一时刻有大量的请求同时去查缓存中没有数据，然后又同时访问数据库（缓存穿透），结果数据库可能扛不住压力。这就需要加锁，最好使用分布式锁。
![[image-131.png]]

但很显然这些请求的处理性能并不好，有没有更好的解决方案？可以把不存在的商品id也缓存起来。
![[image-132.png]]
下次，再有该商品id的请求过来，则也能从缓存中查到数据，只不过该数据比较特殊，表示商品不存在。需要特别注意的是，这种特殊缓存设置的超时时间应该尽量短一点。

# 6 秒杀扣减库存
## 6.1 预扣库存
真正的秒杀商品的场景，不是说扣完库存，就完事了，如果用户在一段时间内，还没完成支付，扣减的库存是要加回去的。
所以，在这里引出了一个**预扣库存**的概念，下单时预扣库存，付款时释放库存(数据库)。
预扣库存的主要流程如下：
![[image-133.png]]
## 6.2 数据库扣减
使用数据库扣减库存，是最简单的实现方案了，假设扣减库存的sql如下：
```sql
update product set stock=stock-1 where id=123;
```

但如何控制库存不足的情况下，不让用户操作呢？这就需要在update之前，先查一下库存是否足够了：
```sql
int stock = mapper.getStockById(123);
if(stock > 0) {
  int count = mapper.updateStock(123);
  if(count > 0) {
    addOrder(123);
  }
}
```
查询操作和更新操作不是原子性的，会导致在并发的场景下，出现**库存超卖**的情况。加锁的话性能就不好。

还有更优雅的处理方案，即**基于数据库的乐观锁**：
```sql
update product set stock=stock-1 where id=product and stock > 0;
```

但需要频繁访问数据库，在高并发的场景下，可能会造成系统雪崩。而且容易出现多个请求同时竞争行锁的情况，造成相互等待从而出现死锁的问题。
## 6.3 redis扣减库存
使用lua脚本扣减库存：
1. 先判断商品id是否存在，如果不存在则直接返回。
2. 如果库存>0，则扣减库存。
3. 如果库存=0，是直接返回，表示库存不足。

# 7 MQ处理下单和支付
三个核心流程中，真正并发量大的是秒杀功能，下单和支付功能实际并发量很小。所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成mq异步处理的。而支付功能，比如支付宝支付，是业务场景本身保证的异步。
![[image-135.png]]
要注意以下消息问题：
- 消息丢失：生产端使用消息发送表和定时任务来解决
- 重复消费：消费端使用消息处理表保证幂等消费

# 8 订单取消问题
如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。
- 一个实现方法是定时任务轮询。
- 另一个方法是使用延迟队列。下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。
	- 达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。
	- 如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。

# 9 限流
有些高手，并不会像我们一样老老实实，通过秒杀页面点击秒杀按钮，抢购商品。他们可能在自己的服务器上，模拟正常用户登录系统，跳过秒杀页面，直接调用秒杀接口。
## 9.1 接口限流
常用的后端限流方法有 **漏桶算法** 和 **令牌桶算法**。
## 9.2 针对性限流
可以对同一用户ID限流。但有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这时需要加同一ip限流功能。
但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。

别以为限制了用户和ip就万事大吉，有些高手甚至可以使用代理，每次都请求都换一个ip。这时可以限制请求的接口总次数。

还可以加验证码，可能更精准一些，同样能限制用户的访问频次，但好处是不会存在误杀的情况。

不过这样有些影响用户体验，我们可以通过提高业务门槛，比如只有会员才能参与秒杀活动，普通注册用户没有权限。或者，只有等级到达3级以上的普通用户，才有资格参加该活动。

---
# 10 引用
2025-04-30 15:59
Status: #idea
Tags: [[Redis]]


# 1 主从同步
Redis 具有高可靠性，又是什么意思呢？其实，这里有两层含义：**一是数据尽量少丢失，二是服务尽量少中断**。AOF 和 RDB 保证了前者，而对于后者，Redis 的做法就是增加副本冗余量，将一份数据同时保存在多个实例上。
Redis 提供了**主从库模式**，以保证数据副本的一致，主从库之间采用的是**读写分离**的方式。

## 1.1 主从库间如何进行第一次同步？
当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 `replicaof`（Redis 5.0 之前使用 `slaveof`）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。

例如，现在有实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），我们在实例 2 上执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：
```sql
replicaof 172.16.19.3 6379
```
接下来的步骤如下：
![[image-121.png]]

==第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备==。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。
具体来说，从库给主库发送 `psync` 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。`psync` 命令包含了**主库的 runID 和复制进度 offset 两个参数**。
- runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。
- offset，此时设为 -1，表示第一次复制。

主库收到 `psync` 命令后，会用 `FULLRESYNC` 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，**`FULLRESYNC` 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库**。

==在第二阶段，主库将所有数据同步给从库==。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。具体来说，主库执行 `bgsave` 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 `replicaof` 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。
在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 **replication buffer**，记录 RDB 文件生成后收到的所有写操作。

==最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库==。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。

## 1.2 主从级联模式分担全量复制时的主库压力
一次全量复制中，对于主库来说，需要完成两个耗时的操作：**生成 RDB 文件和传输 RDB 文件**。如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。

在刚才介绍的主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。现在，**我们可以通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上**。

## 1.3 主从库间网络断了怎么办？
一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为**基于长连接的命令传播**，可以避免频繁建立连接的开销。
在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。**从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步**。

### 1.3.1 repl_backlog_buffer
当主从库断连后，主库会把断连期间收到的写操作命令，继续写入 repl_backlog_buffer 这个缓冲区（之前也一直再写）。
repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置（`master_repl_offset`），从库则会记录自己已经读到的位置（`slave_repl_offset`）。

刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小。
当从库断连又重连之后，通过 `psync` 命令告诉主库自己的 `slave_repl_offset`，然后主库根据自己的 `master_repl_offset` 和 `slave_repl_offset` 来判断是需要全量同步还是把两者之间的命令增量同步给从库。

因为 `repl_backlog_buffer` 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。这种情况下从库连上主库后只能乖乖地进行一次全量同步，所以 `repl_backlog_buffer` 配置尽量大一些，可以降低主从断开后全量同步的概率。

### 1.3.2 repl_backlog_size
我们可以调整 `repl_backlog_size` 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：`缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小`。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 `repl_backlog_size = 缓冲空间大小 * 2`，这也就是 `repl_backlog_size` 的最终值。

### 1.3.3 replication buffer 和 repl_backlog_buffer 的区别
replication buffer 是主从库在进行全量复制时，主库上用于和从库连接的客户端的 buffer，而 repl_backlog_buffer 是为了支持从库增量复制，主库上用于持续保存写操作的一块专用 buffer。
**每个从库对应主库的一个 replication buffer，而多个从库共享一个 repl_backlog_buffer**。repl_backlog_buffer 是一块专用 buffer，在 Redis 服务器启动后，开始一直接收写操作命令。主库和从库会各自记录自己的复制进度，所以，不同的从库在进行恢复时，会把自己的复制进度（`slave_repl_offset`）发给主库，主库就可以和它独立同步。

Redis 提供了`client-output-buffer-limit` 参数限制 replication buffer 的大小，如果超过限制，主库会强制断开这个 client 的连接。也就是说从库处理慢导致主库内存 buffer 的积压达到限制后，主库会强制断开从库的连接，此时主从复制会中断。中断后如果从库再次发起复制请求，那么此时可能会导致恶性循环，引发**复制风暴**，这种情况需要格外注意。

## 1.4 主从全量同步使用 RDB 而不使用 AOF 的原因
1. RDB 文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。而 AOF 文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个 key 的多次冗余操作。在主从全量数据同步时，**传输 RDB 文件可以尽量降低对主库机器网络带宽的消耗**。
    从库在加载 RDB 文件时，一是文件小，读取整个文件的速度会很快；二是因为 RDB 文件存储的都是二进制数据，从库直接按照 RDB 协议解析还原数据即可，速度会非常快，而 AOF 需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比 RDB 会慢得多，所以使用 RDB 进行主从全量同步的成本最低。
2. 假设要使用 AOF 做全量同步，意味着必须打开 AOF 功能，打开 AOF 就要选择文件刷盘的策略，选择不当会严重影响 Redis 性能。而 RDB 只有在需要定时备份和主从全量同步数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启 AOF 的。

# 2 主从选主
## 2.1 哨兵机制
在 Redis 主从集群中，**哨兵机制**是实现主从库自动切换的关键机制。哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：**监控、选主（选择主库）和通知**。

**监控**是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始**自动切换主库**的流程。
**选主**。主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。
**通知**。在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 `replicaof` 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。

在这三个任务中，通知任务相对来说比较简单，哨兵只需要把新主库信息发给从库和客户端，让它们和新主库建立连接就行，并不涉及决策的逻辑。但是，在监控和选主这两个任务中，哨兵需要做出两个决策：
- 在监控任务中，哨兵需要判断主库是否处于下线状态；
- 在选主任务中，哨兵也要决定选择哪个从库实例作为主库。

## 2.2 主观下线和客观下线
如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为**主观下线**。
**哨兵机制通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群**。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。
只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为**客观下线** 。“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例（可以由 Redis 管理员自行设定）判断主库为“主观下线”，才能最终判定主库为“客观下线”。

任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 `is-master-down-by-addr` 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。
一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的 `quorum` 配置项设定的。例如，现在有 5 个哨兵，`quorum` 配置的是 3，那么，一个哨兵需要 3 张赞成票，就可以标记主库为“客观下线”了。

## 2.3 如何选定新主库？
我把哨兵选择新主库的过程称为**筛选 + 打分** 。简单来说，我们在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉。然后，我们再按照一定的规则，给剩下的从库逐个打分，将得分最高的从库选为新主库。

### 2.3.1 筛选条件
在选主时，**除了要检查从库的当前在线状态，还要判断它之前的网络连接状态**。
具体怎么判断呢？使用配置项 `down-after-milliseconds * 10`（在 sentinal.conf 文件进行配置）。其中，`down-after-milliseconds` 是我们认定主从库断连的最大连接超时时间。如果在 `down-after-milliseconds` 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。

### 2.3.2 打分规则
我们可以分别按照三个规则依次进行三轮打分，**这三个规则分别是从库优先级、从库复制进度以及从库 ID 号**。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。
1. **第一轮：优先级最高的从库得分高。**
	用户可以通过 `slave-priority` 配置项（这个参数越小，优先级越高），给不同的从库设置不同优先级。
2. **第二轮：和旧主库同步程度最接近的从库得分高。**
	主库会用 `master_repl_offset` 记录当前的最新写操作在 `repl_backlog_buffer` 中的位置，而从库会用 `slave_repl_offset` 这个值记录当前的复制进度。我们想要找的从库，它的 `slave_repl_offset` 需要最接近 `master_repl_offset`。具体实现是直接比较多个`slave_repl_offset` 的值，哪个大就认定为最接近主库的数据。
3. **第三轮：ID 号小的从库得分高。**
	每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。

### 2.3.3 由哪个哨兵执行主从切换？
在判断主库客观下线后，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为**Leader 选举** 。
任何一个想成为 Leader 的哨兵，要满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的 `quorum` 值。

哨兵对主从库进行的在线状态检查等操作，是属于一种时间事件，用一个定时器来完成，一般来说每100ms 执行一次这些事件。每个哨兵的定时器执行周期都会加上一个小小的随机时间偏移，目的是让每个哨兵执行上述操作的时间能稍微错开些，也是为了避免它们都同时判定主库下线，同时选举 Leader。

## 2.4 哨兵集群消息传递
如果你部署过哨兵集群的话就会知道，在配置哨兵的信息时，我们只需要用到下面的这个配置项，设置主库的 IP 和端口，并没有配置其他哨兵的连接信息：
```bash
sentinel monitor <master-name> <ip> <redis-port> <quorum> 
```
这些哨兵实例既然都不知道彼此的地址，又是怎么组成集群的呢？

### 2.4.1 基于 pub/sub 机制的哨兵集群组成
哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是**发布 / 订阅机制**。
哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。
为了区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。在主从集群中，主库上有一个名为 `__sentinel__:hello` 的频道，不同哨兵就是通过它来相互发现，实现互相通信的。

哨兵除了彼此之间建立起连接形成集群外，还需要和从库建立连接。**这是由哨兵向主库发送 `INFO` 命令来完成的**。主库接受到这个命令后，就会把从库列表返回给哨兵。

### 2.4.2 基于 pub/sub 机制的客户端事件通知
在实际使用哨兵时，我们有时会遇到这样的问题：如何在客户端通过监控了解哨兵进行主从切换的过程呢？比如说，主从切换进行到哪一步了？这其实就是要求，客户端能够获取到哨兵集群在监控、选主、切换这个过程中发生的各种事件。
每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。
![[image-122.png]]
具体的操作步骤是：
1. 客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。
2. 然后，我们可以在客户端执行订阅命令，来获取不同的事件消息。

举个例子，你可以执行如下命令，来订阅“所有实例进入客观下线状态的事件”：
```redis
SUBSCRIBE +odown
```

当哨兵把新主库选择出来后，客户端就会看到下面的 `switch-master` 事件。这个事件表示主库已经切换了，新主库的 IP 地址和端口信息已经有了。这个时候，客户端就可以用这里面的新主库地址和端口进行通信了：
```bash
switch-master <master name> <oldip> <oldport> <newip> <newport>
```

# 3 切片集群
**切片集群，也叫分片集群**，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。
切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在 Redis 3.0 之前，官方并没有针对切片集群提供具体的方案。从 3.0 开始，官方提供了一个名为 **Redis Cluster** 的方案，用于实现切片集群。Redis Cluster 方案中就规定了数据和实例的对应规则。

## 3.1 数据切片和实例的对应分布关系
Redis Cluster 方案采用**哈希槽（Hash Slot**，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。

具体的映射过程分为两大步：
1. 首先根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值；
2. 然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。

我们在部署 Redis Cluster 方案时，可以使用 `cluster create` 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。
我们也可以使用 `cluster meet` 命令手动建立实例间的连接，形成集群，再使用 `cluster addslots` 命令，指定每个实例上的哈希槽个数。在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。

## 3.2 客户端如何定位数据？
### 3.2.1 哈希槽信息扩散和缓存
在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。
Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。
客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。

但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：
1. 在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；
2. 为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。
此时，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。这就会导致，它缓存的分配信息和最新的分配信息就不一致了，那该怎么办呢？

### 3.2.2 重定向机制
Redis Cluster 方案提供了一种**重定向机制**，所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。

#### 3.2.2.1 MOVED 命令
当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 **`MOVED` 命令**响应结果，这个结果中就包含了新实例的访问地址。
```sql
GET hello:key
(error) MOVED 13320 172.16.19.5:6379
```
客户端同时还会更新本地缓存，把对应关系更新过来。

#### 3.2.2.2 ASK 命令
在实际应用时，如果一个哈希槽中的数据比较多，就可能会出现一种情况：客户端向实例 2 发送请求，但此时，哈希槽中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移。在这种迁移部分完成的情况下，客户端就会收到一条 **`ASK` 报错信息**，如下所示：
```
GET hello:key
(error) ASK 13320 172.16.19.5:6379
```
这个结果中的 `ASK` 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个哈希槽正在迁移。
此时，客户端需要先给 172.16.19.5 这个实例发送一个 `ASKING` 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。因为槽位没有迁移完成，在新的Redis实例上不会管理这个槽位。如果直接从新实例上获取，就会返回错误。然后，客户端再向这个实例发送 `GET` 命令，以读取数据。

和 MOVED 命令不同，**ASK 命令并不会更新客户端缓存的哈希槽分配信息**。

---
# 4 引用